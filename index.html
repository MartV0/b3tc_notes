<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-01-31 Wed 12:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes</title>
<meta name="author" content="Martijn Voordouw" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Notes</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org3698752">1. Introduction</a>
<ul>
<li><a href="#org334df26">1.1. Definitions</a></li>
<li><a href="#org0d611a3">1.2. Course</a>
<ul>
<li><a href="#org78c4186">1.2.1. In this course</a></li>
<li><a href="#orgc2f01de">1.2.2. Learning goals</a></li>
</ul>
</li>
<li><a href="#orgbe6d2cb">1.3. Haskell</a></li>
<li><a href="#org582aedb">1.4. Language and sets</a></li>
<li><a href="#org2120b56">1.5. Summary</a></li>
</ul>
</li>
<li><a href="#orgef7506b">2. Grammars and parsing</a>
<ul>
<li><a href="#org84783e0">2.1. Grammar</a>
<ul>
<li><a href="#org462f4dd">2.1.1. Grammar and productions</a></li>
<li><a href="#org6cf7b44">2.1.2. Restricted grammars/context free</a></li>
<li><a href="#org5e63fbd">2.1.3. Examples:</a></li>
<li><a href="#orgfa47dfc">2.1.4. Ambiguity</a></li>
<li><a href="#orga41f385">2.1.5. Grammar transformations</a></li>
</ul>
</li>
<li><a href="#org95c882f">2.2. Parsing</a>
<ul>
<li><a href="#org1f403e3">2.2.1. Parsing problem</a></li>
<li><a href="#org56bcd26">2.2.2. Parse trees in haskell</a></li>
</ul>
</li>
<li><a href="#orge891f86">2.3. Summary</a></li>
</ul>
</li>
<li><a href="#orgc2ab7e4">3. Parser Combinators</a>
<ul>
<li><a href="#orgebd3860">3.1. Parser data type</a></li>
<li><a href="#org400fbf4">3.2. Actual parse data type is slightly different</a></li>
<li><a href="#org0a81d4f">3.3. Implementing &lt;*&gt; and &lt;$&gt;</a></li>
<li><a href="#orgd5b1806">3.4. Examples &lt;*&gt; and &lt;$&gt;</a></li>
<li><a href="#orgc401f92">3.5. Guard</a></li>
<li><a href="#orgbf4940b">3.6. Choice: &lt;|&gt;</a></li>
<li><a href="#orgad540b2">3.7. Longest</a></li>
<li><a href="#org4390aa3">3.8. &lt;$ &lt;* and *&gt;</a></li>
<li><a href="#org40cf028">3.9. succeed and epsilon</a></li>
<li><a href="#org420a6ac">3.10. empty</a></li>
<li><a href="#orgc90fadb">3.11. satisfy and symbol</a>
<ul>
<li><a href="#org687d1ad">3.11.1. satify</a></li>
<li><a href="#orgdc3d4d9">3.11.2. symbol</a></li>
</ul>
</li>
<li><a href="#org90d7ff2">3.12. Biased choice: &lt;&lt;|&gt;</a></li>
<li><a href="#org041fdee">3.13. Bind: &gt;&gt;=</a></li>
<li><a href="#orge310ba1">3.14. do notation</a></li>
<li><a href="#orgecc9a25">3.15. Applicative functors and monads</a></li>
<li><a href="#org2665396">3.16. option</a></li>
<li><a href="#org531ec6c">3.17. many, some, listOf and greedy</a>
<ul>
<li><a href="#orgf5ca65f">3.17.1. many</a></li>
<li><a href="#org8b625fb">3.17.2. some</a></li>
<li><a href="#org4384121">3.17.3. listOf</a></li>
<li><a href="#orgb348b84">3.17.4. greedy</a></li>
<li><a href="#org6fc35ca">3.17.5. greedy1</a></li>
</ul>
</li>
<li><a href="#orgb647399">3.18. chainl and chainr</a></li>
</ul>
</li>
<li><a href="#org3d4890d">4. Parser design</a>
<ul>
<li><a href="#orgb228a48">4.1. Grammar transformations</a>
<ul>
<li><a href="#orgeab736b">4.1.1. Removing duplicates</a></li>
<li><a href="#orge1a0d0f">4.1.2. Left factoring</a></li>
</ul>
</li>
<li><a href="#org140c96a">4.2. Operators</a>
<ul>
<li><a href="#org78b602b">4.2.1. Parsing associative operators</a></li>
<li><a href="#org541fa3c">4.2.2. Parsing associative operators of different priorities </a></li>
<li><a href="#orgb1ad592">4.2.3. A general operator parser</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org89c9f84">5. Regular Expressions</a>
<ul>
<li><a href="#orgd621153">5.1. A simpler subset of parser combinators</a></li>
<li><a href="#orgdfce288">5.2. Regular Expression</a></li>
<li><a href="#org8904f8f">5.3. Limitations of regular expressions/languages</a></li>
</ul>
</li>
<li><a href="#org27631dc">6. Finite State Machines</a>
<ul>
<li><a href="#orgefd40c3">6.1. Moore Machine</a>
<ul>
<li><a href="#orgeb5c871">6.1.1. Example: moore machine for lamp</a></li>
<li><a href="#org1ba38e0">6.1.2. Advantages of Moore Machines</a></li>
<li><a href="#orgfeced2a">6.1.3. Running Moore Machines</a></li>
</ul>
</li>
<li><a href="#org091688a">6.2. Moore Machines for RegExp Matching</a>
<ul>
<li><a href="#org1624690">6.2.1. Examples</a></li>
<li><a href="#orgef2b9e3">6.2.2. Compiling Regular Expressions to DFA</a></li>
<li><a href="#org0f95758">6.2.3. Regex to Non Deterministic Finite Automaton (NFA)</a></li>
<li><a href="#orga5d045f">6.2.4. Running NFAε</a></li>
<li><a href="#org314ca8a">6.2.5. Performance of the NFA regex</a></li>
<li><a href="#org32cda94">6.2.6. Converting NFAε to DFA</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb2d9e27">7. Folding</a>
<ul>
<li><a href="#org3249542">7.1. List folding</a></li>
<li><a href="#org424f031">7.2. Matched parentheses</a></li>
<li><a href="#org149455e">7.3. Arithmetic expressions</a></li>
<li><a href="#orga3b57dd">7.4. Building a fold for any datatype</a>
<ul>
<li><a href="#orgc60395e">7.4.1. Trees example</a></li>
</ul>
</li>
<li><a href="#org3ca4b42">7.5. <span class="todo TODO">TODO</span> Fix</a></li>
<li><a href="#orgff06400">7.6. Algebra for families of datatypes</a></li>
<li><a href="#orgebc4ee4">7.7. RepMax fold</a></li>
</ul>
</li>
<li><a href="#org531965f">8. Simple Stack Machine</a>
<ul>
<li><a href="#org55565f6">8.1. Documentation</a></li>
<li><a href="#org1a01c34">8.2. Architecture</a></li>
<li><a href="#org6c794b3">8.3. Instructions</a>
<ul>
<li><a href="#org42d807e">8.3.1. <code>LDC</code> - load constant</a></li>
<li><a href="#org01d762e">8.3.2. <code>LDR</code> - load from register</a></li>
<li><a href="#orga579b7c">8.3.3. <code>LDL</code> - loal local</a></li>
<li><a href="#orgcc57093">8.3.4. <code>LDS</code> - load from stack</a></li>
<li><a href="#org854ce0e">8.3.5. <code>LDLA</code> - load local adress</a></li>
<li><a href="#orgadd13b0">8.3.6. <code>LDA</code> - load via adress</a></li>
<li><a href="#org2c5445a">8.3.7. <code>LDRR</code> - load register from register</a></li>
<li><a href="#org253fee1">8.3.8. <code>NOP</code> - noop</a></li>
<li><a href="#org8a282f2">8.3.9. <code>HALT</code> - halt program</a></li>
<li><a href="#orgffa501a">8.3.10. <code>AJS</code> - adjust stack pointer</a></li>
<li><a href="#orgc5ccd77">8.3.11. <code>BRA</code> - unconditional branch</a></li>
<li><a href="#org5f2207e">8.3.12. <code>BSR</code> - branch to subroutine</a></li>
<li><a href="#orgf87a547">8.3.13. <code>RET</code> - return from subroutine</a></li>
<li><a href="#org9b26fdd">8.3.14. <code>STR</code> - store to register</a></li>
<li><a href="#org725e591">8.3.15. <code>STS</code> - store into stack</a></li>
<li><a href="#org3e230a7">8.3.16. <code>STL</code> - store local</a></li>
<li><a href="#org2e1cff1">8.3.17. Operators</a></li>
</ul>
</li>
<li><a href="#org8f27475">8.4. Translating programs</a>
<ul>
<li><a href="#orge6f7250">8.4.1. Translating expressions</a></li>
<li><a href="#orgab856a9">8.4.2. Statements</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org87df0d5">9. Validation</a>
<ul>
<li><a href="#org509feec">9.1. Example checks at AST level</a></li>
</ul>
</li>
<li><a href="#org7167768">10. Pumping Lemmas, proving (non)regular languages</a>
<ul>
<li><a href="#orge01b8b8">10.1. General strategy for proving a language (non) regular</a></li>
<li><a href="#org6a4e217">10.2. Proving a language non-regular</a>
<ul>
<li><a href="#org28db763">10.2.1. Strategy step 1: limitation in the formalism</a></li>
<li><a href="#org851f637">10.2.2. Step 2: property of language class</a></li>
<li><a href="#org6b66cf7">10.2.3. Step 3: pumping lemma</a></li>
</ul>
</li>
<li><a href="#org4dcadac">10.3. <span class="todo TODO">TODO</span> Proving context-free grammar</a>
<ul>
<li><a href="#org6f73ef9">10.3.1. Step 1: limitation in the formalism</a></li>
<li><a href="#orgba62083">10.3.2. Step 2: property of language class</a></li>
<li><a href="#org6ecad38">10.3.3. Step 3: pumping lemma</a></li>
</ul>
</li>
<li><a href="#orge3e1585">10.4. Normal forms</a>
<ul>
<li><a href="#org171b0be">10.4.1. Chomksy Normal Form</a></li>
<li><a href="#orgd717739">10.4.2. Greibach Normal Form</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org286a50f">11. Nanopass Compilation</a>
<ul>
<li><a href="#org6543bbb">11.1. Nanopass passes</a>
<ul>
<li><a href="#org6a07812">11.1.1. Parse</a></li>
<li><a href="#org3a1cef6">11.1.2. Type-Check</a></li>
<li><a href="#org972bf2c">11.1.3. for → while</a></li>
<li><a href="#org24f9084">11.1.4. λ → class</a></li>
<li><a href="#org5650775">11.1.5. class → struct</a></li>
<li><a href="#org68546ec">11.1.6. Insert Reference-Counting code</a></li>
<li><a href="#org5e0f78a">11.1.7. Constant folding</a></li>
<li><a href="#orgc778cf2">11.1.8. if,while, &#x2026; → goto</a></li>
<li><a href="#orge31e81e">11.1.9. SSM instructions → x86<sub>64</sub> instructions</a></li>
</ul>
</li>
<li><a href="#orgfba7281">11.2. Nano parse abstract syntax tree?</a>
<ul>
<li><a href="#orgc1cba6b">11.2.1. Many ASTs</a></li>
<li><a href="#orgb13f85a">11.2.2. One AST</a></li>
<li><a href="#org80c5731">11.2.3. Generics</a></li>
<li><a href="#org0fa1756">11.2.4. One AST, with refinements</a></li>
<li><a href="#org68f5b4d">11.2.5. One AST, with parameters</a></li>
<li><a href="#org3033098">11.2.6. <span class="todo TODO">TODO</span> One AST, with parameter + type functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd0d4052">12. Optimizations</a>
<ul>
<li><a href="#orgbef7bed">12.1. Optimization passes</a></li>
<li><a href="#org99a0ef4">12.2. Simple optimizations</a>
<ul>
<li><a href="#org53423eb">12.2.1. Unreachable/dead code elimination:</a></li>
<li><a href="#org2c99213">12.2.2. Tail call elimination:</a></li>
</ul>
</li>
<li><a href="#org066b2ec">12.3. Loop optimization</a>
<ul>
<li><a href="#org57a7975">12.3.1. Loop unrolling</a></li>
<li><a href="#orgc7d5156">12.3.2. Loop invariant code motion</a></li>
<li><a href="#org0068862">12.3.3. Loop fusion</a></li>
<li><a href="#orgff27d28">12.3.4. Loop fission</a></li>
</ul>
</li>
<li><a href="#org83586f1">12.4. Other optimizations</a>
<ul>
<li><a href="#orgae731a2">12.4.1. Inlining</a></li>
<li><a href="#orgc038c22">12.4.2. Common Subexpression Elimination</a></li>
</ul>
</li>
<li><a href="#org389e682">12.5. Compiler pipeline</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org3698752" class="outline-2">
<h2 id="org3698752"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org334df26" class="outline-3">
<h3 id="org334df26"><span class="section-number-3">1.1.</span> Definitions</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>A <b>language</b> is a set of &ldquo;correct&rdquo; sentences</li>
<li>A <b>compiler</b> translates one language into another (possibly the same)</li>
</ul>

<p>
Computer science studies information processing.
</p>
<ul class="org-ul">
<li>We describe and transfer <b>information</b> by means of <b>language</b></li>
<li>Information is obtained by assigning <b>meaning</b> to <b>sentences</b></li>
<li>The <b>meaning</b> of a sentence is inferred from its <b>structure</b></li>
<li>The <b>structure</b> of a sentence is described by means of a <b>grammar</b></li>
</ul>
</div>
</div>
<div id="outline-container-org0d611a3" class="outline-3">
<h3 id="org0d611a3"><span class="section-number-3">1.2.</span> Course</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org78c4186" class="outline-4">
<h4 id="org78c4186"><span class="section-number-4">1.2.1.</span> In this course</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>Classes (“difficulty levels”) of languages
<ul class="org-ul">
<li>context-free languages</li>
<li>regular languages</li>
</ul></li>
<li>Describing languages formally, using
<ul class="org-ul">
<li>grammars</li>
<li>finite state automata</li>
</ul></li>
<li>Grammar transformations
<ul class="org-ul">
<li>for simplification</li>
<li>for obtaining more efficient parsers</li>
</ul></li>
<li>Parsing context-free and regular languages, using
<ul class="org-ul">
<li>parser combinators</li>
<li>parser generators</li>
<li>finite state automata</li>
</ul></li>
<li>How to go from syntax to semantics</li>
</ul>
</div>
</div>
<div id="outline-container-orgc2f01de" class="outline-4">
<h4 id="orgc2f01de"><span class="section-number-4">1.2.2.</span> Learning goals</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>To describe structures (i.e., “formulas”) using grammars;</li>
<li>To parse, i.e., to recognise (build) such structures in (from) a sequence of symbols;</li>
<li>To analyse grammars to see whether or not specific properties hold;</li>
<li>To compose components such as parsers, analysers, and code generators;</li>
<li>To apply these techniques in the construction of all kinds of programs;</li>
<li>To explain and prove why certain problems can or cannot be described by means of formalisms such as context-free grammars or finite-state automata.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbe6d2cb" class="outline-3">
<h3 id="orgbe6d2cb"><span class="section-number-3">1.3.</span> Haskell</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Haskell is used because many concept from formal language theory have a direct correspondence in Haskell
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Formal languages</th>
<th scope="col" class="org-left">Haskell</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">alphabet</td>
<td class="org-left">datatype</td>
</tr>

<tr>
<td class="org-left">sequence</td>
<td class="org-left">list type</td>
</tr>

<tr>
<td class="org-left">sentence/word</td>
<td class="org-left">a concrete list</td>
</tr>

<tr>
<td class="org-left">abstract syntax</td>
<td class="org-left">datatype</td>
</tr>

<tr>
<td class="org-left">grammar</td>
<td class="org-left">parser</td>
</tr>

<tr>
<td class="org-left">grammar transformation</td>
<td class="org-left">parser transformation</td>
</tr>

<tr>
<td class="org-left">parse tree</td>
<td class="org-left">value of abstract syntax type</td>
</tr>

<tr>
<td class="org-left">semantics</td>
<td class="org-left">fold function, algebra</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org582aedb" class="outline-3">
<h3 id="org582aedb"><span class="section-number-3">1.4.</span> Language and sets</h3>
<div class="outline-text-3" id="text-1-4">
<p>
An <b>alphabet</b> is a set of symbols that can be used to form sentences
</p>

<p>
Given a set A. The set of <b>sequences over A</b>, written A*, is defined as follows:
</p>
<ul class="org-ul">
<li>The empyt sequence \(\epsilon\) is in \(A^*\)</li>
<li>If \(a\in A\) and \(z\in A^*\), then \(az\) is in \(A^*\)</li>
</ul>

<p>
Given an alphabat A, a <b>language</b> is a subset of \(A^*\)
</p>

<p>
We can define such a set in multiple ways:
</p>
<ul class="org-ul">
<li>By enumerating all elements</li>
<li>By using a predicate
<ul class="org-ul">
<li>\(PAL=\{s\in A^*|s=s^R\}\) is the language of palindromes over A</li>
</ul></li>
<li>By giving an inductive definition
<ul class="org-ul">
<li>ε is in PAL,</li>
<li>a, b, c are in PAL,</li>
<li>if P is in PAL, then aPa, bPb and cPc are also in PAL</li>
<li>An inductive definition gives us more structure and makes it easier to explain why a sentence is in the language</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2120b56" class="outline-3">
<h3 id="org2120b56"><span class="section-number-3">1.5.</span> Summary</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<b>Alphabet:</b> A finite set of symbols.
</p>

<p>
<b>Language:</b> A set of words/sentences, i.e., sequences of symbols from the alphabet.
</p>

<p>
<b>Grammar:</b> A way to define a language inductively by means of rewrite rules.
</p>
</div>
</div>
</div>
<div id="outline-container-orgef7506b" class="outline-2">
<h2 id="orgef7506b"><span class="section-number-2">2.</span> Grammars and parsing</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org84783e0" class="outline-3">
<h3 id="org84783e0"><span class="section-number-3">2.1.</span> Grammar</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org462f4dd" class="outline-4">
<h4 id="org462f4dd"><span class="section-number-4">2.1.1.</span> Grammar and productions</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
A <b>grammar</b> is formalism to describe a language inductively.
Grammer consist of rewrite rules, called productions
 <img src="Grammar/2023-11-16_13-27-59_screenshot.png" alt="2023-11-16_13-27-59_screenshot.png" />
</p>
<ul class="org-ul">
<li>A grammar consists of multiple <b>productions</b>. Productions can be seen as rewrite rules.</li>
<li>The grammer makes use of auxiliary symbols, called <b>nonterminals</b>, that are not part of the alphabet and hence cannot be part of the final word/sentence</li>
<li>The symbols from the alphabet are also called <b>terminals</b>.</li>
</ul>
<p>
Grammars can have multiple nonterminal
<img src="Grammar/2023-11-16_13-29-37_screenshot.png" alt="2023-11-16_13-29-37_screenshot.png" />
One nonterminal in the grammar is called the <b>start symbol</b>
</p>
</div>
</div>
<div id="outline-container-org6cf7b44" class="outline-4">
<h4 id="org6cf7b44"><span class="section-number-4">2.1.2.</span> Restricted grammars/context free</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
We consider only restricted grammars:
</p>
<ul class="org-ul">
<li>The left hand side of a production always consists of a single nonterminal</li>
</ul>
<p>
Grammars with this restriction are called <b>context-free</b>
</p>

<ul class="org-ul">
<li>Not all languages can be generated/described by a grammar.</li>
<li>Multiple grammars may describe the same language.</li>
<li>Grammars which generate the same language are equivalent.</li>
<li>Even fewer languages can be described by a context-free grammar.</li>
<li>Languages that can be described by a context-free grammar are called context-free languages.</li>
<li>Context-free languages are relatively easy to deal with algorithmically, and therefore most programming languages are context-free languages</li>
</ul>
</div>
</div>
<div id="outline-container-org5e63fbd" class="outline-4">
<h4 id="org5e63fbd"><span class="section-number-4">2.1.3.</span> Examples:</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
natural numbers without leading zeros
</p>
<ul class="org-ul">
<li>Dig-0 → 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</li>
<li>Nat → 0 | Dig-0 Digs</li>
</ul>
<p>
Integers:
</p>
<ul class="org-ul">
<li>Sign → + | -</li>
<li>Int → Sign Nat | Nat
or..</li>
<li>Int → Sign? Nat</li>
</ul>
<p>
Fragment of C#:
</p>
<ul class="org-ul">
<li>Stat → Var = Expr ;</li>
<li>| if ( Expr ) Stat else Stat</li>
<li>| while ( Expr ) Stat</li>
<li>Expr → Integer</li>
<li>| Var</li>
<li>| Expr Op Expr</li>
<li>Var → Identifier</li>
<li>Op → Sign | *</li>
</ul>
</div>
</div>
<div id="outline-container-orgfa47dfc" class="outline-4">
<h4 id="orgfa47dfc"><span class="section-number-4">2.1.4.</span> Ambiguity</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
A grammar where every sentence corresponds to a unique parse tree is called <b>unambiguous</b>.
If this is not the case the grammar is called <b>ambiguous</b>.
</p>

<p>
<i>Example ambiguous grammar:</i>
</p>
<ul class="org-ul">
<li>S → SS</li>
<li>S → a</li>
</ul>

<p>
Famous ambiguity problem:
</p>
<ul class="org-ul">
<li>S → if b then S else S</li>
<li>| if b then S</li>
<li>| a</li>
</ul>
<p>
consider:
</p>
<ul class="org-ul">
<li>if b then if b then a else a</li>
</ul>

<p>
Ambiguity is a property of grammars:
</p>
<ul class="org-ul">
<li>All of these grammars describe the same language
<img src="Grammar/2023-11-16_14-02-37_screenshot.png" alt="2023-11-16_14-02-37_screenshot.png" /></li>
<li>Not al of these are ambiguous</li>
</ul>
</div>
</div>
<div id="outline-container-orga41f385" class="outline-4">
<h4 id="orga41f385"><span class="section-number-4">2.1.5.</span> Grammar transformations</h4>
<div class="outline-text-4" id="text-2-1-5">
<p>
A <b>grammar transformation</b> is a mapping from one grammar to another, such that the generated language remains the same.
</p>

<p>
Formally:
A grammar transformation maps a grammer G to another grammar G&rsquo; such that:
\(L(G)=L(G')\)
</p>

<p>
Grammar transformations can help us to transform grammars with undesirable properties (such as ambiguity) into grammars with other (hopefully better) properties.
</p>

<p>
Most grammar transformations are motivated by facilitating parsing
</p>
</div>
</div>
</div>
<div id="outline-container-org95c882f" class="outline-3">
<h3 id="org95c882f"><span class="section-number-3">2.2.</span> Parsing</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org1f403e3" class="outline-4">
<h4 id="org1f403e3"><span class="section-number-4">2.2.1.</span> Parsing problem</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Given a grammar G and a string s, the <b>parsing problem</b> is to decide wether or not \(s\in L(G)\)
</p>

<p>
Furthermore, if \(s\in L(G)\), we want evidence/proof/an explantion why this is the case, usually in the form of a parse tree.
</p>
</div>
</div>
<div id="outline-container-org56bcd26" class="outline-4">
<h4 id="org56bcd26"><span class="section-number-4">2.2.2.</span> Parse trees in haskell</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Consider this grammar:
</p>
<ul class="org-ul">
<li>S → S-D | D</li>
<li>D → 0 | 1</li>
</ul>

<p>
Represent nonterminals as <b>datatypes</b>:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">S</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Minus</span> <span style="color: #ECBE7B;">S</span> <span style="color: #ECBE7B;">D</span> <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">SingleDigit</span> <span style="color: #ECBE7B;">D</span>
<span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">D</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Zero</span> <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">One</span>
</pre>
</div>

<p>
The string 1-0-1 corresponds to the parse tree
</p>

<div id="org5d85053" class="figure">
<p><img src="Parsing/2023-11-17_11-50-16_screenshot.png" alt="2023-11-17_11-50-16_screenshot.png" />
</p>
</div>

<p>
In haskell:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ECBE7B;">Minus</span> (<span style="color: #ECBE7B;">Minus</span> (<span style="color: #ECBE7B;">SingleDigit</span> <span style="color: #ECBE7B;">One</span>) <span style="color: #ECBE7B;">Zero</span>) <span style="color: #ECBE7B;">One</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">printS</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">S</span> <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">String</span>
<span style="color: #c678dd;">printS</span> (<span style="color: #ECBE7B;">Minus</span> s d) <span style="color: #dcaeea;">=</span> printS s <span style="color: #dcaeea;">++</span> <span style="color: #98be65;">"-"</span> <span style="color: #dcaeea;">++</span> printD d
<span style="color: #c678dd;">printS</span> (<span style="color: #ECBE7B;">SingleDigit</span> d) <span style="color: #dcaeea;">=</span> printD d
<span style="color: #c678dd;">printD</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">D</span> <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">String</span>
<span style="color: #c678dd;">printD</span> <span style="color: #ECBE7B;">Zero</span> <span style="color: #dcaeea;">=</span> <span style="color: #98be65;">"0"</span>
<span style="color: #c678dd;">printD</span> <span style="color: #ECBE7B;">One</span> <span style="color: #dcaeea;">=</span> <span style="color: #98be65;">"1"</span>

<span style="color: #c678dd;">sample</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Minus</span> (<span style="color: #ECBE7B;">Minus</span> (<span style="color: #ECBE7B;">SingleDigit</span> <span style="color: #ECBE7B;">One</span>) <span style="color: #ECBE7B;">Zero</span>) <span style="color: #ECBE7B;">One</span>

<span style="color: #c678dd;">main</span> <span style="color: #dcaeea;">=</span> putStrLn (printS sample) <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">"1-0-1"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge891f86" class="outline-3">
<h3 id="orge891f86"><span class="section-number-3">2.3.</span> Summary</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<b>Grammar</b> A way to describe a language inductively.
</p>

<p>
<b>Production</b> A rewrite rule in a grammar.
</p>

<p>
<b>Context-free</b> The class of grammars/languages we consider.
</p>

<p>
<b>Nonterminal</b> Auxiliary symbols in a grammar.
</p>

<p>
<b>Terminal</b> Alphabet symbols in a grammar.
</p>

<p>
<b>Derivation</b> Successively rewriting from a grammar until we reach a sentence.
</p>

<p>
<b>Parse</b> tree Tree representation of a derivation.
</p>

<p>
<b>Ambiguity</b> Multiple parse trees for the same sentence.
</p>

<p>
<b>Abstract</b> syntax (Haskell) Datatype corresponding to a grammar.
</p>

<p>
<b>Semantic</b> function Function defined on the abstract syntax.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc2ab7e4" class="outline-2">
<h2 id="orgc2ab7e4"><span class="section-number-2">3.</span> Parser Combinators</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgebd3860" class="outline-3">
<h3 id="orgebd3860"><span class="section-number-3">3.1.</span> Parser data type</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">parseDate5</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Date</span>
<span style="color: #c678dd;">parseMonth5</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Month</span>
<span style="color: #c678dd;">parseDay5</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Day</span>

<span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">-&gt;</span> [(a,<span style="color: #ECBE7B;">String</span>)]
</pre>
</div>

<p>
Defining a parser could look like this:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">parseDate5</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Date</span>
<span style="color: #c678dd;">parseDate5</span> input <span style="color: #dcaeea;">=</span> [(<span style="color: #ECBE7B;">Date</span> d m,tail')
    <span style="color: #dcaeea;">|</span> (d,tail ) <span style="color: #dcaeea;">&lt;-</span> parseDay5 input
    , (m,tail') <span style="color: #dcaeea;">&lt;-</span> parseMonth5 tail]
</pre>
</div>
<p>
This is a repetitive pattern, and quite error prone.
</p>

<p>
We want it to look like this:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">parseDate6</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Date</span> <span style="color: #dcaeea;">&lt;$&gt;</span> parseDay <span style="color: #dcaeea;">&lt;*&gt;</span> parseMonth
</pre>
</div>

<p>
Notice this is similar to regular haskell function application, &lt;$&gt; -&gt; $ and &lt;*&gt; -&gt; .
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;$&gt;</span> <span style="color: #dcaeea;">::</span> (<span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> (<span style="color: #ECBE7B;">Month</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Date</span>))
    <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Int</span>
    <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> (<span style="color: #ECBE7B;">Month</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Date</span>)

<span style="color: #dcaeea;">&lt;*&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> (<span style="color: #ECBE7B;">Month</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Date</span>)
    <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Month</span>
    <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Date</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org400fbf4" class="outline-3">
<h3 id="org400fbf4"><span class="section-number-3">3.2.</span> Actual parse data type is slightly different</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The actual type also has what type of symbol we are trying to parse, usually char.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">Parser</span> a c <span style="color: #dcaeea;">=</span> [c] <span style="color: #dcaeea;">-&gt;</span> [(a,[c])]

(<span style="color: #c678dd;">&lt;*&gt;</span>) <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s (a <span style="color: #dcaeea;">-&gt;</span> b) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s b
(<span style="color: #c678dd;">&lt;|&gt;</span>) <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a
(<span style="color: #c678dd;">&lt;$&gt;</span>) <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> b) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> b
</pre>
</div>

<p>
Using the parser
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">parse</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">&#8594;</span> [s] <span style="color: #dcaeea;">&#8594;</span> [(a, [s])]
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">Examples:</span>
<span style="color: #c678dd;">parse</span> ints <span style="color: #98be65;">"23,11"</span> <span style="color: #dcaeea;">==</span> [((<span style="color: #da8548; font-weight: bold;">23</span>, <span style="color: #da8548; font-weight: bold;">11</span>), <span style="color: #98be65;">""</span>)]
<span style="color: #c678dd;">parse</span> ints <span style="color: #98be65;">"23,11bla"</span> <span style="color: #dcaeea;">==</span> [((<span style="color: #da8548; font-weight: bold;">23</span>, <span style="color: #da8548; font-weight: bold;">11</span>), <span style="color: #98be65;">"bla"</span>)]
<span style="color: #c678dd;">parse</span> ints <span style="color: #98be65;">"whatever"</span> <span style="color: #dcaeea;">==</span> <span style="color: #ECBE7B;">[]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0a81d4f" class="outline-3">
<h3 id="org0a81d4f"><span class="section-number-3">3.3.</span> Implementing &lt;*&gt; and &lt;$&gt;</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;$&gt;</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> b) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> b

(f <span style="color: #dcaeea;">&lt;$&gt;</span> parse) input <span style="color: #dcaeea;">=</span> [ (f x, tail)
    <span style="color: #dcaeea;">|</span> (x, tail) <span style="color: #dcaeea;">&lt;-</span> parse input]
</pre>
</div>

<p>
Examples
</p>
<div class="org-src-container">
<pre class="src src-haskell">((<span style="color: #da8548; font-weight: bold;">1</span><span style="color: #dcaeea;">+</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> parseNat) <span style="color: #98be65;">"100"</span> <span style="color: #dcaeea;">==</span> [(<span style="color: #da8548; font-weight: bold;">101</span>,<span style="color: #98be65;">""</span>)]
(map toUpper <span style="color: #dcaeea;">&lt;$&gt;</span> parseString <span style="color: #98be65;">"hello"</span>) <span style="color: #98be65;">"hello world"</span> <span style="color: #dcaeea;">==</span> [(<span style="color: #98be65;">"HELLO"</span>,<span style="color: #98be65;">" world"</span>)]
</pre>
</div>
<p>
Ussually this isn&rsquo;t used directly, more often then not combined with &lt;*&gt;
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;*&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> (a <span style="color: #dcaeea;">-&gt;</span> b) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> b
(pf <span style="color: #dcaeea;">&lt;*&gt;</span> px) input <span style="color: #dcaeea;">=</span> [ (f x, tail1)
    <span style="color: #dcaeea;">|</span> (f, tail1) <span style="color: #dcaeea;">&lt;-</span> pf input
    , (x, tail2) <span style="color: #dcaeea;">&lt;-</span> px tail1]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd5b1806" class="outline-3">
<h3 id="orgd5b1806"><span class="section-number-3">3.4.</span> Examples &lt;*&gt; and &lt;$&gt;</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Examples:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ECBE7B;">(,)</span> <span style="color: #dcaeea;">&lt;$&gt;</span> parseNat <span style="color: #dcaeea;">&lt;*&gt;</span> parseString <span style="color: #98be65;">" green bottles"</span> <span style="color: #dcaeea;">$</span> <span style="color: #98be65;">"42 green bottles hanging on the wall"</span>
    <span style="color: #dcaeea;">==</span> [((<span style="color: #da8548; font-weight: bold;">42</span>,<span style="color: #98be65;">" green bottles"</span>),<span style="color: #98be65;">" hanging on the wall"</span>)]

fst <span style="color: #c678dd;">&lt;$&gt;</span> (<span style="color: #ECBE7B;">(,)</span> <span style="color: #dcaeea;">&lt;$&gt;</span> parseNat <span style="color: #dcaeea;">&lt;*&gt;</span> parseString <span style="color: #98be65;">" green bott "</span> <span style="color: #da8548; font-weight: bold;">42</span> green bottles hanging on the wall<span style="color: #ECBE7B;">"</span>
    <span style="color: #dcaeea;">==</span> [(<span style="color: #da8548; font-weight: bold;">42</span>,<span style="color: #98be65;">" hanging on the wall"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc401f92" class="outline-3">
<h3 id="orgc401f92"><span class="section-number-3">3.5.</span> Guard</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Only succeed if the result of a parser satisfys a given predicate
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">guard</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a
<span style="color: #c678dd;">guard</span> cond parser input <span style="color: #dcaeea;">=</span> [ (result, tail)
    <span style="color: #dcaeea;">|</span> (result, tail) <span style="color: #dcaeea;">&lt;-</span> parser input
    , cond result]
</pre>
</div>

<p>
Can also be defined using &gt;&gt;= (see further ahead for more details)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">guard</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a
<span style="color: #c678dd;">guard</span> cond parser <span style="color: #dcaeea;">=</span> parser <span style="color: #dcaeea;">&gt;&gt;=</span> <span style="color: #dcaeea;">\</span>a <span style="color: #dcaeea;">-&gt;</span>
    <span style="color: #51afef;">if</span> cond a <span style="color: #51afef;">then</span> succeed a <span style="color: #51afef;">else</span> empty
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbf4940b" class="outline-3">
<h3 id="orgbf4940b"><span class="section-number-3">3.6.</span> Choice: &lt;|&gt;</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Parses using either or both parsers
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;|&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a
(p1 <span style="color: #dcaeea;">&lt;|&gt;</span> p2) input <span style="color: #dcaeea;">=</span> p1 input <span style="color: #dcaeea;">++</span> p2 input
</pre>
</div>

<p>
choice takes a list of parsers and combines them in sequence, returning a list of results.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">choice</span> <span style="color: #dcaeea;">::</span> [<span style="color: #ECBE7B;">Parser</span> s a] <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">choice</span> <span style="color: #dcaeea;">=</span> foldr (<span style="color: #dcaeea;">&lt;|&gt;</span>) empty
</pre>
</div>
</div>
</div>
<div id="outline-container-orgad540b2" class="outline-3">
<h3 id="orgad540b2"><span class="section-number-3">3.7.</span> Longest</h3>
<div class="outline-text-3" id="text-3-7">
<p>
This function isn&rsquo;t actually in library, but could still be a usefull example for a low level parser
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">longest</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a
<span style="color: #c678dd;">longest</span> parser input
    <span style="color: #dcaeea;">=</span> concat
    <span style="color: #dcaeea;">.</span> take <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #dcaeea;">.</span> groupBy ((<span style="color: #dcaeea;">==</span>) <span style="color: #dcaeea;">`on`</span> length <span style="color: #dcaeea;">.</span> snd)
    <span style="color: #dcaeea;">.</span> sortOn (length <span style="color: #dcaeea;">.</span> snd)
    <span style="color: #dcaeea;">.</span> parser
    <span style="color: #dcaeea;">$</span> input
</pre>
</div>
</div>
</div>
<div id="outline-container-org4390aa3" class="outline-3">
<h3 id="org4390aa3"><span class="section-number-3">3.8.</span> &lt;$ &lt;* and *&gt;</h3>
<div class="outline-text-3" id="text-3-8">
<p>
All of these are made for ignoring the result of a parser
</p>
<ul class="org-ul">
<li>Basically only use the argument if the parser succeeds</li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;$</span> <span style="color: #dcaeea;">::</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> b <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a
(x <span style="color: #dcaeea;">&lt;$</span> p) <span style="color: #dcaeea;">=</span> const x <span style="color: #dcaeea;">&lt;$&gt;</span> p
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #c678dd;">&lt;*</span>) <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s b <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a
p <span style="color: #c678dd;">&lt;*</span> q <span style="color: #dcaeea;">=</span> const <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> q
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #c678dd;">*&gt;</span>) <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s b <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s b
p <span style="color: #c678dd;">*&gt;</span> q <span style="color: #dcaeea;">=</span> flip const <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> q
</pre>
</div>
</div>
</div>
<div id="outline-container-org40cf028" class="outline-3">
<h3 id="org40cf028"><span class="section-number-3">3.9.</span> succeed and epsilon</h3>
<div class="outline-text-3" id="text-3-9">
<p>
Creates a parser that always results in the same value, doesn&rsquo;t consume anything from the input string
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">succeed</span> <span style="color: #dcaeea;">::</span> a <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">succeed</span> r xs <span style="color: #dcaeea;">=</span> [(r,xs)]

<span style="color: #c678dd;">epsilon</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s <span style="color: #ECBE7B;">()</span>
<span style="color: #c678dd;">epsilon</span> <span style="color: #dcaeea;">=</span> succeed <span style="color: #ECBE7B;">()</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org420a6ac" class="outline-3">
<h3 id="org420a6ac"><span class="section-number-3">3.10.</span> empty</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Parser that always fails
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">empty</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">empty</span> xs <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">[]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc90fadb" class="outline-3">
<h3 id="orgc90fadb"><span class="section-number-3">3.11.</span> satisfy and symbol</h3>
<div class="outline-text-3" id="text-3-11">
</div>
<div id="outline-container-org687d1ad" class="outline-4">
<h4 id="org687d1ad"><span class="section-number-4">3.11.1.</span> satify</h4>
<div class="outline-text-4" id="text-3-11-1">
<p>
satisfy takes a predicate and returns a parser that parses a single symbol satisfying that predicate.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">satisfy</span>  <span style="color: #dcaeea;">::</span>  (s <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s s
<span style="color: #c678dd;">satisfy</span> p (x<span style="color: #ECBE7B;">:</span>xs) <span style="color: #dcaeea;">|</span> p x <span style="color: #dcaeea;">=</span> [(x,xs)]
<span style="color: #c678dd;">satisfy</span> <span style="color: #51afef;">_</span> <span style="color: #51afef;">_</span>            <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">[]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdc3d4d9" class="outline-4">
<h4 id="orgdc3d4d9"><span class="section-number-4">3.11.2.</span> symbol</h4>
<div class="outline-text-4" id="text-3-11-2">
<p>
symbol parses a specific given symbol
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">symbol</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Eq</span> s  <span style="color: #dcaeea;">=&gt;</span> s <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s s
<span style="color: #c678dd;">symbol</span> x <span style="color: #dcaeea;">=</span> satisfy (<span style="color: #dcaeea;">==</span>x)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org90d7ff2" class="outline-3">
<h3 id="org90d7ff2"><span class="section-number-3">3.12.</span> Biased choice: &lt;&lt;|&gt;</h3>
<div class="outline-text-3" id="text-3-12">
<p>
Biased choice. If the left hand side parser succeeds, the right hand side is not considered.
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #c678dd;">&lt;&lt;|&gt;</span>) <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Parser</span> s a
(p <span style="color: #dcaeea;">&lt;&lt;|&gt;</span> q) <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>xs <span style="color: #dcaeea;">&#8594;</span> <span style="color: #51afef;">if</span> null (p xs) <span style="color: #51afef;">then</span> q xs <span style="color: #51afef;">else</span> p xs
</pre>
</div>
</div>
</div>
<div id="outline-container-org041fdee" class="outline-3">
<h3 id="org041fdee"><span class="section-number-3">3.13.</span> Bind: &gt;&gt;=</h3>
<div class="outline-text-3" id="text-3-13">
<p>
Monadic bind
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #c678dd;">&gt;&gt;=</span>) <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> (a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s b) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s b
p <span style="color: #c678dd;">&gt;&gt;=</span> f <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>xs <span style="color: #dcaeea;">-&gt;</span> [(s, zs) <span style="color: #dcaeea;">|</span> (r, ys) <span style="color: #dcaeea;">&lt;-</span> p xs
                         , (s , zs) <span style="color: #dcaeea;">&lt;-</span> f r ys]
</pre>
</div>

<p>
We can use bind to redefine guard
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">guard</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a
<span style="color: #c678dd;">guard</span> cond parser <span style="color: #dcaeea;">=</span> parser <span style="color: #dcaeea;">&gt;&gt;=</span> <span style="color: #dcaeea;">\</span>a <span style="color: #dcaeea;">-&gt;</span>
    <span style="color: #51afef;">if</span> cond a <span style="color: #51afef;">then</span> succeed a <span style="color: #51afef;">else</span> empty
</pre>
</div>

<p>
Another example of the use of this &gt;&gt;= primitive: we parse 1 number, and then parse that many other numbers:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">pSizedList</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> [<span style="color: #ECBE7B;">Int</span>]
<span style="color: #c678dd;">pSizedList</span> <span style="color: #dcaeea;">=</span>
     natural                <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">parse the size</span>
  <span style="color: #dcaeea;">&lt;*</span> spaces                 <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">discard whitespace</span>
  <span style="color: #dcaeea;">&gt;&gt;=</span> <span style="color: #dcaeea;">\</span>size <span style="color: #dcaeea;">-&gt;</span>              <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">use the size to build a new parser for the rest of the input</span>
  sequence                  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">collapse a list of parsers into a parser of a list</span>
    (replicate size         <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">repeat the following parser `size` times</span>
      (natural <span style="color: #dcaeea;">&lt;*</span> spaces))  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">parse a number and discard whitespace</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orge310ba1" class="outline-3">
<h3 id="orge310ba1"><span class="section-number-3">3.14.</span> do notation</h3>
<div class="outline-text-3" id="text-3-14">
<p>
Because we have defined the bind operator we can also use the do notation!
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">guard</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> a
<span style="color: #c678dd;">guard</span> cond parser <span style="color: #dcaeea;">=</span> <span style="color: #51afef;">do</span>
    a <span style="color: #dcaeea;">&lt;-</span> parser
    <span style="color: #51afef;">if</span> cond a <span style="color: #51afef;">then</span> return a <span style="color: #51afef;">else</span> empty
</pre>
</div>

<p>
Function to parse a number then parse that many lines
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">parseNLines</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> [<span style="color: #ECBE7B;">String</span>]
<span style="color: #c678dd;">parseNLines</span> <span style="color: #dcaeea;">=</span> <span style="color: #51afef;">do</span>
    n <span style="color: #dcaeea;">&#8592;</span> natural
    <span style="color: #51afef;">_</span> <span style="color: #dcaeea;">&#8592;</span> symbol <span style="color: #98be65;">'\n'</span>
    sequence <span style="color: #dcaeea;">$</span> replicate n parseLine
        <span style="color: #51afef;">where</span> parseLine <span style="color: #dcaeea;">=</span> many (satisfy (<span style="color: #dcaeea;">/=</span> <span style="color: #98be65;">'\n'</span>)) <span style="color: #dcaeea;">&lt;*</span> symbol <span style="color: #98be65;">'\n'</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgecc9a25" class="outline-3">
<h3 id="orgecc9a25"><span class="section-number-3">3.15.</span> Applicative functors and monads</h3>
<div class="outline-text-3" id="text-3-15">
<p>
The operations parsers support are very common, many other types support the same interface(s).
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Functor</span> f <span style="color: #51afef;">where</span>
<span style="color: #c678dd;">fmap</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> b) <span style="color: #dcaeea;">-&gt;</span> f a <span style="color: #dcaeea;">-&gt;</span> f b
(<span style="color: #c678dd;">&lt;$&gt;</span>) <span style="color: #dcaeea;">=</span> fmap

<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Functor</span> f <span style="color: #dcaeea;">=&gt;</span> <span style="color: #ECBE7B;">Applicative</span> f <span style="color: #51afef;">where</span>
<span style="color: #c678dd;">pure</span> <span style="color: #dcaeea;">::</span> a <span style="color: #dcaeea;">-&gt;</span> f a
(<span style="color: #c678dd;">&lt;*&gt;</span>) <span style="color: #dcaeea;">::</span> f (a <span style="color: #dcaeea;">-&gt;</span> b) <span style="color: #dcaeea;">-&gt;</span> f a <span style="color: #dcaeea;">-&gt;</span> f b

<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Applicative</span> f <span style="color: #dcaeea;">=&gt;</span> <span style="color: #ECBE7B;">Alternative</span> f <span style="color: #51afef;">where</span>
<span style="color: #c678dd;">empty</span> <span style="color: #dcaeea;">::</span> f a
(<span style="color: #c678dd;">&lt;|&gt;</span>) <span style="color: #dcaeea;">::</span> f a <span style="color: #dcaeea;">-&gt;</span> f a <span style="color: #dcaeea;">-&gt;</span> f a

<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Monad</span> m <span style="color: #51afef;">where</span>
(<span style="color: #c678dd;">&gt;&gt;=</span>) <span style="color: #dcaeea;">::</span> m a <span style="color: #dcaeea;">-&gt;</span> (a <span style="color: #dcaeea;">-&gt;</span> m b) <span style="color: #dcaeea;">-&gt;</span> m b
</pre>
</div>
</div>
</div>
<div id="outline-container-org2665396" class="outline-3">
<h3 id="org2665396"><span class="section-number-3">3.16.</span> option</h3>
<div class="outline-text-3" id="text-3-16">
<p>
Parses an optional element. Takes the default value as its second argument.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">option</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">&#8594;</span> a <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">option</span> p def <span style="color: #dcaeea;">=</span> p <span style="color: #dcaeea;">&lt;|&gt;</span> succeed d
</pre>
</div>
</div>
</div>
<div id="outline-container-org531ec6c" class="outline-3">
<h3 id="org531ec6c"><span class="section-number-3">3.17.</span> many, some, listOf and greedy</h3>
<div class="outline-text-3" id="text-3-17">
</div>
<div id="outline-container-orgf5ca65f" class="outline-4">
<h4 id="orgf5ca65f"><span class="section-number-4">3.17.1.</span> many</h4>
<div class="outline-text-4" id="text-3-17-1">
<p>
Parses many, i.e., zero or more, occurrences of a given parser.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">many</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a  <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s [a]
<span style="color: #c678dd;">many</span> p  <span style="color: #dcaeea;">=</span>  (<span style="color: #ECBE7B;">:</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> many p <span style="color: #dcaeea;">&lt;|&gt;</span> succeed <span style="color: #ECBE7B;">[]</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b625fb" class="outline-4">
<h4 id="org8b625fb"><span class="section-number-4">3.17.2.</span> some</h4>
<div class="outline-text-4" id="text-3-17-2">
<p>
Parser some, i.e., one or more, occurrences of a given parser.
</p>

<p>
Also called many1.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">some</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s [a]
<span style="color: #c678dd;">some</span> p <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">:</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> many p
</pre>
</div>
</div>
</div>
<div id="outline-container-org4384121" class="outline-4">
<h4 id="org4384121"><span class="section-number-4">3.17.3.</span> listOf</h4>
<div class="outline-text-4" id="text-3-17-3">
<p>
Takes a parser p and a separator parser s. Parses a sequence of p&rsquo;s that is separated by s&rsquo;s
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">listOf</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s b <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s [a]
<span style="color: #c678dd;">listOf</span> p s <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">:</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> many (s <span style="color: #dcaeea;">*&gt;</span> p)
</pre>
</div>

<p>
listOf example: parse digits seperated by `hi`
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">seperatedByHi</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> [<span style="color: #ECBE7B;">Char</span>]
<span style="color: #c678dd;">seperatedByHi</span> <span style="color: #dcaeea;">=</span> listOf digit (token <span style="color: #98be65;">"hi"</span>)

<span style="color: #c678dd;">main</span> <span style="color: #dcaeea;">=</span> print <span style="color: #dcaeea;">$</span> seperatedByHi <span style="color: #98be65;">"7hi2hi4"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb348b84" class="outline-4">
<h4 id="orgb348b84"><span class="section-number-4">3.17.4.</span> greedy</h4>
<div class="outline-text-4" id="text-3-17-4">
<p>
Greedy variant of <a href="#orgf5ca65f">many</a> will always parse the most amount it can
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">greedy</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s [a]
<span style="color: #c678dd;">greedy</span> p <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">:</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> greedy p <span style="color: #dcaeea;">&lt;&lt;|&gt;</span> succeed <span style="color: #ECBE7B;">[]</span>
</pre>
</div>

<p>
Example difference between greedy and many:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">parse</span> (greedy (symbol <span style="color: #98be65;">'a'</span>)) <span style="color: #98be65;">"aaaaaaabbbbbb"</span>
</pre>
</div>

<p>
Meanwhile many also return all the intermediate results
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">parse</span> (many (symbol <span style="color: #98be65;">'a'</span>)) <span style="color: #98be65;">"aaaaaaabbbbbb"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org6fc35ca" class="outline-4">
<h4 id="org6fc35ca"><span class="section-number-4">3.17.5.</span> greedy1</h4>
<div class="outline-text-4" id="text-3-17-5">
<p>
Greedy variant of <a href="#org8b625fb">some</a>:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">greedy1</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s [a]
<span style="color: #c678dd;">greedy1</span> p <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">:</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> greedy p
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb647399" class="outline-3">
<h3 id="orgb647399"><span class="section-number-3">3.18.</span> chainl and chainr</h3>
<div class="outline-text-3" id="text-3-18">
<p>
For more details see <a href="#org7fa672c">operators</a>
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">chainl</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s (a <span style="color: #dcaeea;">-&gt;</span> a <span style="color: #dcaeea;">-&gt;</span> a) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">chainl</span> p s <span style="color: #dcaeea;">=</span> foldl (flip (<span style="color: #dcaeea;">$</span>)) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> many (flip <span style="color: #dcaeea;">&lt;$&gt;</span> s <span style="color: #dcaeea;">&lt;*&gt;</span> p)

<span style="color: #c678dd;">chainr</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s (a <span style="color: #dcaeea;">-&gt;</span> a <span style="color: #dcaeea;">-&gt;</span> a) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">chainr</span> p s <span style="color: #dcaeea;">=</span> flip (foldr (<span style="color: #dcaeea;">$</span>)) <span style="color: #dcaeea;">&lt;$&gt;</span> many (flip (<span style="color: #dcaeea;">$</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> s) <span style="color: #dcaeea;">&lt;*&gt;</span> p
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3d4890d" class="outline-2">
<h2 id="org3d4890d"><span class="section-number-2">4.</span> Parser design</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgb228a48" class="outline-3">
<h3 id="orgb228a48"><span class="section-number-3">4.1.</span> Grammar transformations</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-orgeab736b" class="outline-4">
<h4 id="orgeab736b"><span class="section-number-4">4.1.1.</span> Removing duplicates</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
A → u | u | v
</p>

<p>
can be transformed into
</p>

<p>
A → u | v
</p>

<p>
Parser:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">a</span> <span style="color: #dcaeea;">=</span> u <span style="color: #dcaeea;">&lt;|&gt;</span> u <span style="color: #dcaeea;">&lt;|&gt;</span> v
</pre>
</div>

<p>
becomes
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">a</span> <span style="color: #dcaeea;">=</span> u <span style="color: #dcaeea;">&lt;|&gt;</span> v
</pre>
</div>
</div>
</div>
<div id="outline-container-orge1a0d0f" class="outline-4">
<h4 id="orge1a0d0f"><span class="section-number-4">4.1.2.</span> Left factoring</h4>
<div class="outline-text-4" id="text-4-1-2">
</div>
<ol class="org-ol">
<li><a id="org20d7a51"></a>Left recursion<br />
<div class="outline-text-5" id="text-4-1-2-1">
<p>
A production is called <b>left-recursive</b> if the right hand side starts with the nonterminal of the left hand side.
</p>

<p>
Example:
</p>

<p>
A → Az
</p>

<p>
corresponds to a parser
</p>

<p>
a = a &lt;*&gt; z
</p>
<ul class="org-ul">
<li>This parser would loop</li>
<li>Removing left recursion is essential for a combinator parser</li>
</ul>

<p>
A grammar is called <b>left-recursive</b> if A ⇒+ Az for some nonterminal A of the grammar.
</p>
</div>
</li>
<li><a id="orgdbe490c"></a>Removing left recursion<br />
<div class="outline-text-5" id="text-4-1-2-2">
<p>
First, split the productions for A into left-recursive and others:
</p>

<p>
\[A → Ax_1 | Ax_2 | . . . | A x_n\]
</p>

<p>
\[A → y_1 | y_2 | . . . | y_m \text{ \{-(none of the yi start with A) -\}}\]
</p>

<p>
Second add a second non-terminal for all the left recursive terms like this:
</p>

<p>
\[A → y_1Z | y_2Z | . . . | y_mZ\]
</p>

<p>
\[Z → ε | x_1Z | x_2Z | . . . | x_nZ\]
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org140c96a" class="outline-3">
<h3 id="org140c96a"><span class="section-number-3">4.2.</span> Operators</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org78b602b" class="outline-4">
<h4 id="org78b602b"><span class="section-number-4">4.2.1.</span> Parsing associative operators</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Consider a grammar for simple equations:
</p>

<p>
E → E O E | Nat
</p>

<p>
O → + | -
</p>

<p>
​- is not an assosiative operator, it is usually defined as associating to the left
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Plus</span> <span style="color: #ECBE7B;">E</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Minus</span> <span style="color: #ECBE7B;">E</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Nat</span> <span style="color: #ECBE7B;">Int</span>
</pre>
</div>

<p>
1+2-3+4 should parse as
</p>

<div class="org-src-container">
<pre class="src src-haskell">((<span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">1</span> &#8216;<span style="color: #ECBE7B;">Plus</span>&#8216; <span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">2</span>) &#8216;<span style="color: #ECBE7B;">Minus</span>&#8216; <span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">3</span>) &#8216;<span style="color: #ECBE7B;">Plus</span>&#8216; <span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">4</span>
</pre>
</div>

<p>
This can obtained using:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">foldl</span> (flip (<span style="color: #dcaeea;">$</span>)) (<span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">1</span>) [(&#8216;<span style="color: #ECBE7B;">Plus</span>&#8216; <span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">2</span>), (&#8216;<span style="color: #ECBE7B;">Minus</span>&#8216; <span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">3</span>), (&#8216;<span style="color: #ECBE7B;">Plus</span>&#8216; <span style="color: #ECBE7B;">Nat</span> <span style="color: #da8548; font-weight: bold;">4</span>)]
</pre>
</div>

<p>
We can write a parser using the chainl function that has the above result
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">chainl</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s (a <span style="color: #dcaeea;">-&gt;</span> a <span style="color: #dcaeea;">-&gt;</span> a) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">chainl</span> p s <span style="color: #dcaeea;">=</span> foldl (flip (<span style="color: #dcaeea;">$</span>)) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> many (flip <span style="color: #dcaeea;">&lt;$&gt;</span> s <span style="color: #dcaeea;">&lt;*&gt;</span> p)

<span style="color: #c678dd;">e</span> <span style="color: #dcaeea;">=</span> chainl (<span style="color: #ECBE7B;">Nat</span> <span style="color: #dcaeea;">&lt;$&gt;</span> natural) o
<span style="color: #c678dd;">o</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Plus</span> <span style="color: #dcaeea;">&lt;$</span> symbol <span style="color: #98be65;">'+'</span> <span style="color: #dcaeea;">&lt;|&gt;</span> <span style="color: #ECBE7B;">Minus</span> <span style="color: #dcaeea;">&lt;$</span> symbol <span style="color: #98be65;">'-'</span>
</pre>
</div>

<p>
There is also chainr for right associative chains
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">chainr</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> s a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s (a <span style="color: #dcaeea;">-&gt;</span> a <span style="color: #dcaeea;">-&gt;</span> a) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> s a
<span style="color: #c678dd;">chainr</span> p s <span style="color: #dcaeea;">=</span> flip (foldr (<span style="color: #dcaeea;">$</span>)) <span style="color: #dcaeea;">&lt;$&gt;</span> many (flip (<span style="color: #dcaeea;">$</span>) <span style="color: #dcaeea;">&lt;$&gt;</span> p <span style="color: #dcaeea;">&lt;*&gt;</span> s) <span style="color: #dcaeea;">&lt;*&gt;</span> p
</pre>
</div>

<p>
chainl and chainr can be used for some common occurrences of left recursion.
</p>
</div>
</div>
<div id="outline-container-org541fa3c" class="outline-4">
<h4 id="org541fa3c"><span class="section-number-4">4.2.2.</span> Parsing associative operators of different priorities <a id="org7fa672c"></a></h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
The basic idea is to associate operators of different priorities with different non-terminals.
</p>

<p>
For each priority level i, we get
\[E_i \rightarrow E_i\ Op_i\ E_{i+1}\ |\ E_{i+1} \text{ (for left-associative operators)}\]
or
\[E_i \rightarrow E_{i+1}\ Op_i\ E_{i}\ |\ E_{i+1} \text{ (for right-associative operators)}\]
or
\[E_i \rightarrow E_{i+1}\ Op_i\ E_{i+1}\ |\ E_{i+1} \text{ (for non-associative operators)}\]
</p>

<p>
Applied to
\[ E \rightarrow E + E\]
\[ E \rightarrow E - E\]
\[ E \rightarrow E * E\]
\[ E \rightarrow ( E )\]
\[ E \rightarrow Nat \]
we obtain:
\[ E_1  \rightarrow E_1\ Op_1\ E_2\ |\ E_2 \]
\[ E_2  \rightarrow E_2\ Op_2\ E_3\ |\ E_3 \]
\[ E_3  \rightarrow ( E_1 ) | Nat \]
\[ Op_1 \rightarrow + | - \]
\[ Op_2 \rightarrow * \]
</p>

<p>
Since the abstract syntax tree structure makes the nesting explicit, it typically makes sense to derive the Haskell datatype from the ambiguous grammar:
</p>
<ul class="org-ul">
<li>same for parantheses</li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Plus</span> <span style="color: #ECBE7B;">E</span> <span style="color: #ECBE7B;">E</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Minus</span> <span style="color: #ECBE7B;">E</span> <span style="color: #ECBE7B;">E</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Times</span> <span style="color: #ECBE7B;">E</span> <span style="color: #ECBE7B;">E</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Nat</span>
</pre>
</div>

<p>
Now we can use chainl and chainr again for each of the levels
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">e1, e2, e3</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #c678dd;">e1</span> <span style="color: #dcaeea;">=</span> chainl e2 op1
<span style="color: #c678dd;">e2</span> <span style="color: #dcaeea;">=</span> chainl e3 op2
<span style="color: #c678dd;">e3</span> <span style="color: #dcaeea;">=</span> parenthesised e1 <span style="color: #dcaeea;">&lt;|&gt;</span> <span style="color: #ECBE7B;">Nat</span> <span style="color: #dcaeea;">&lt;$&gt;</span> natural

<span style="color: #c678dd;">op1, op2</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> (<span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>)
<span style="color: #c678dd;">op1</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Plus</span> <span style="color: #dcaeea;">&lt;$</span> symbol <span style="color: #98be65;">'+'</span> <span style="color: #dcaeea;">&lt;|&gt;</span> <span style="color: #ECBE7B;">Minus</span> <span style="color: #dcaeea;">&lt;$</span> symbol <span style="color: #98be65;">'-'</span>
<span style="color: #c678dd;">op2</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Times</span> <span style="color: #dcaeea;">&lt;$</span> symbol <span style="color: #98be65;">'*'</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb1ad592" class="outline-4">
<h4 id="orgb1ad592"><span class="section-number-4">4.2.3.</span> A general operator parser</h4>
<div class="outline-text-4" id="text-4-2-3">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">Op</span> a <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">Char</span>, a <span style="color: #dcaeea;">-&gt;</span> a <span style="color: #dcaeea;">-&gt;</span> a)
<span style="color: #c678dd;">gen</span> <span style="color: #dcaeea;">::</span> [<span style="color: #ECBE7B;">Op</span> a] <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> a
<span style="color: #c678dd;">gen</span> ops p <span style="color: #dcaeea;">=</span> chainl p (choice (map (<span style="color: #dcaeea;">\</span>(s, c) <span style="color: #dcaeea;">-&gt;</span> c <span style="color: #dcaeea;">&lt;$</span> symbol s) ops))
</pre>
</div>

<p>
now the parser looks like this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">e1</span> <span style="color: #dcaeea;">=</span> gen [(&#8217;<span style="color: #dcaeea;">+</span>&#8217;, <span style="color: #ECBE7B;">Plus</span>), (&#8217;<span style="color: #dcaeea;">-</span>&#8217;, <span style="color: #ECBE7B;">Minus</span>)] e2
<span style="color: #c678dd;">e2</span> <span style="color: #dcaeea;">=</span> gen [(&#8217;<span style="color: #dcaeea;">*</span>&#8217;, <span style="color: #ECBE7B;">Times</span>)] e3
</pre>
</div>

<p>
We could also do without the intermediate levels using a fold
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">e1</span> <span style="color: #dcaeea;">=</span> foldr gen e3 [[(&#8217;<span style="color: #dcaeea;">+</span>&#8217;, <span style="color: #ECBE7B;">Plus</span>), (&#8217;<span style="color: #dcaeea;">-</span>&#8217;, <span style="color: #ECBE7B;">Minus</span>)], [(&#8217;<span style="color: #dcaeea;">*</span>&#8217;, <span style="color: #ECBE7B;">Times</span>)]]
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org89c9f84" class="outline-2">
<h2 id="org89c9f84"><span class="section-number-2">5.</span> Regular Expressions</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgd621153" class="outline-3">
<h3 id="orgd621153"><span class="section-number-3">5.1.</span> A simpler subset of parser combinators</h3>
<div class="outline-text-3" id="text-5-1">
<p>
We would like to create a simple subset of parser combinators
</p>
<ul class="org-ul">
<li>Should work in other languages</li>
<li>Works in for example a search bar</li>
</ul>

<p>
For this language we only consider char as the input type and string as the output type.
</p>
<ul class="org-ul">
<li>So it only parses a string to a string</li>
</ul>

<p>
We have to convert the primitive &lt;*&gt; because it is a higher order function.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;*&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">P</span> (a <span style="color: #dcaeea;">-&gt;</span> b) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">P</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">P</span> b
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;</span>,<span style="color: #dcaeea;">&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">P</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">P</span> b <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">P</span> (a, b)
</pre>
</div>

<p>
We only want string as a result so we convert &lt;,&gt; to:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;+&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">P</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">P</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">P</span> <span style="color: #ECBE7B;">String</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #dcaeea;">&lt;|&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span>
<span style="color: #dcaeea;">&lt;+&gt;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span>
<span style="color: #c678dd;">many</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span>
<span style="color: #c678dd;">many1</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span>
<span style="color: #c678dd;">option</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span>
<span style="color: #c678dd;">symbol</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Char</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span>
<span style="color: #c678dd;">satisfy</span> <span style="color: #dcaeea;">::</span> (<span style="color: #ECBE7B;">Char</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">R</span>
<span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">R</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Parser</span> <span style="color: #ECBE7B;">Char</span> <span style="color: #ECBE7B;">String</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdfce288" class="outline-3">
<h3 id="orgdfce288"><span class="section-number-3">5.2.</span> Regular Expression</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The following expressions in the simplified languages can be converted to regex:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Haskell</th>
<th scope="col" class="org-left">Regular Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">p1 &lt;&vert;&gt; p2</td>
<td class="org-left">r1&vert;r2</td>
</tr>

<tr>
<td class="org-left">p1 &lt;+&gt; p2</td>
<td class="org-left">r1r2</td>
</tr>

<tr>
<td class="org-left">many    p</td>
<td class="org-left">r*</td>
</tr>

<tr>
<td class="org-left">many1   p</td>
<td class="org-left">r+</td>
</tr>

<tr>
<td class="org-left">option  p</td>
<td class="org-left">r?</td>
</tr>

<tr>
<td class="org-left">symbol  c</td>
<td class="org-left">c</td>
</tr>

<tr>
<td class="org-left">satisfy isDigit</td>
<td class="org-left"><code>\d</code></td>
</tr>

<tr>
<td class="org-left">satisfy isWhitespace</td>
<td class="org-left"><code>\s</code></td>
</tr>

<tr>
<td class="org-left">satisfy (not . isWhitespace)</td>
<td class="org-left"><code>\S</code></td>
</tr>

<tr>
<td class="org-left">satisfy (`elem` [&rsquo;a&rsquo;..&rsquo;z&rsquo;])</td>
<td class="org-left">[a-z]</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org8904f8f" class="outline-3">
<h3 id="org8904f8f"><span class="section-number-3">5.3.</span> Limitations of regular expressions/languages</h3>
<div class="outline-text-3" id="text-5-3">
<p>
No parsing
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">matchRegExp</span> <span style="color: #98be65;">"</span><span style="color: #ECBE7B;">\</span><span style="color: #98be65;">w+ on (toast|bread)"</span> <span style="color: #98be65;">"beans on toasted potato"</span> <span style="color: #dcaeea;">==</span> [<span style="color: #98be65;">"beans on toast"</span>]
</pre>
</div>

<p>
No recursion
</p>
<ul class="org-ul">
<li>No matching brackets for example</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org27631dc" class="outline-2">
<h2 id="org27631dc"><span class="section-number-2">6.</span> Finite State Machines</h2>
<div class="outline-text-2" id="text-6">
<p>
We want to create a efficient algorithm for matching regular expressions.
</p>
</div>
<div id="outline-container-orgefd40c3" class="outline-3">
<h3 id="orgefd40c3"><span class="section-number-3">6.1.</span> Moore Machine</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Computers are complicated so instead we consider a <b>Moore Machine</b>
</p>


<div id="org81c9121" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_10-40-53_screenshot.png" alt="2024-01-03_10-40-53_screenshot.png" />
</p>
</div>

<p>
Moore machine can also be known as:
</p>
<ul class="org-ul">
<li><b>Finite State Machine (FSM)</b></li>
<li><b>Finite State Automaton (FSA)</b></li>
<li><b>Deterministic Finite Automaton (DFA)</b>: result is true or false. <a id="orgcac8e86"></a>
<ul class="org-ul">
<li>This is what we end up using for regular expression matching</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgeb5c871" class="outline-4">
<h4 id="orgeb5c871"><span class="section-number-4">6.1.1.</span> Example: moore machine for lamp</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
We can model the function of a lamp with three buttons using a moore machine
</p>
<ul class="org-ul">
<li>It has a button for cold and warm light, we can also turn it on</li>
<li>The on/off button remembers the last light color</li>
</ul>

<p>
It can be modeled in haskell like this:
</p>


<div id="orgc9ffb2a" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_11-07-49_screenshot.png" alt="2024-01-03_11-07-49_screenshot.png" />
</p>
</div>

<p>
As a Moore Machine:
</p>


<div id="org80e713c" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_11-08-48_screenshot.png" alt="2024-01-03_11-08-48_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org1ba38e0" class="outline-4">
<h4 id="org1ba38e0"><span class="section-number-4">6.1.2.</span> Advantages of Moore Machines</h4>
<div class="outline-text-4" id="text-6-1-2">
<ul class="org-ul">
<li>Easy to use</li>
<li>Easy to modify</li>
<li>Easy to verify</li>
<li>Easy to implement
<ul class="org-ul">
<li>Programming languages</li>
<li>Hardware</li>
<li>Mathematics</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Moore</span> event memory output <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Moore</span>
    { step <span style="color: #dcaeea;">::</span> event <span style="color: #dcaeea;">-&gt;</span> memory <span style="color: #dcaeea;">-&gt;</span> memory
    , genOut <span style="color: #dcaeea;">::</span> memory <span style="color: #dcaeea;">-&gt;</span> output
    , s0 <span style="color: #dcaeea;">::</span> memory}

<span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">DFA</span> symbol state <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Moore</span> symbol state <span style="color: #ECBE7B;">Bool</span>
</pre>
</div>

<p>
See above example for an implementation
</p>

<p>
A Moore machine can be defined a a 6-tuple \((S,s_0,\Sigma,O,\delta,G)\)
</p>
<ul class="org-ul">
<li>A finite set of states \(S\)</li>
<li>A initial state \(s_0\) which is an element of S</li>
<li>A finite set called the input alphabet \(\Sigma\)</li>
<li>A finite set called the output alphabet \(O\)</li>
<li>A transition function \(\delta : S \times \Sigma \rightarrow S\) mapping a state and the input to the next state</li>
<li>An output function \(G:S\rightarrow O\) mapping each state to the output alphabet</li>
</ul>

<p>
You probably don&rsquo;t have to learn the above by heart, just an example of how a moore machine can be implemented
</p>
</div>
</div>
<div id="outline-container-orgfeced2a" class="outline-4">
<h4 id="orgfeced2a"><span class="section-number-4">6.1.3.</span> Running Moore Machines</h4>
<div class="outline-text-4" id="text-6-1-3">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">runMoore</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Moore</span> inp state out <span style="color: #dcaeea;">-&gt;</span> [inp] <span style="color: #dcaeea;">-&gt;</span> state
<span style="color: #c678dd;">runMoore</span> (<span style="color: #ECBE7B;">Moore</span> step <span style="color: #51afef;">_</span> s0) <span style="color: #dcaeea;">=</span> foldr step s0

<span style="color: #c678dd;">runDFA</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">DFA</span> symbol state <span style="color: #dcaeea;">-&gt;</span> [symbol] <span style="color: #dcaeea;">-&gt;</span> state
<span style="color: #c678dd;">runDFA</span> <span style="color: #dcaeea;">=</span> runMoore

<span style="color: #c678dd;">matchesDFA</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">DFA</span> symbol state <span style="color: #dcaeea;">-&gt;</span> [symbol] <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>
<span style="color: #c678dd;">matchesDFA</span> dfa <span style="color: #dcaeea;">=</span> genOutput dfa <span style="color: #dcaeea;">.</span> runDFA dfa
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org091688a" class="outline-3">
<h3 id="org091688a"><span class="section-number-3">6.2.</span> Moore Machines for RegExp Matching</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org1624690" class="outline-4">
<h4 id="org1624690"><span class="section-number-4">6.2.1.</span> Examples</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
An example Moore Machine for the regular expression <code>a*aaaba*</code>
</p>


<div id="org690b122" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_12-14-00_screenshot.png" alt="2024-01-03_12-14-00_screenshot.png" />
</p>
</div>

<p>
Another example with expression <code>(0b)?(0|1)+</code>, which matches a binary number such as <code>0b001</code> or <code>100101</code>
</p>


<div id="orgc185628" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_12-18-03_screenshot.png" alt="2024-01-03_12-18-03_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgef2b9e3" class="outline-4">
<h4 id="orgef2b9e3"><span class="section-number-4">6.2.2.</span> Compiling Regular Expressions to DFA</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Not all of regular expressions have a direct and easy translation to DFA, this is why we end up using NFAε
</p>
<ul class="org-ul">
<li>Later we convert the NFAε back to DFA, i know somewhat confusing, but its easier that way.</li>
</ul>

<p>
<code>c</code>
</p>


<div id="orgb07ce46" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_12-33-29_screenshot.png" alt="2024-01-03_12-33-29_screenshot.png" />
</p>
</div>

<p>
<code>\d</code>
<img src="Finite_State_Machines/2024-01-03_12-34-45_screenshot.png" alt="2024-01-03_12-34-45_screenshot.png" />
</p>

<p>
<code>[x-z]</code>
<img src="Finite_State_Machines/2024-01-03_12-35-07_screenshot.png" alt="2024-01-03_12-35-07_screenshot.png" />
</p>

<p>
r<sub>1</sub>​r<sub>2</sub>
</p>
<ul class="org-ul">
<li>Every succes state of r<sub>1</sub> should be linked to the beginning of r<sub>2</sub></li>
</ul>

<div id="orgb26b66b" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_12-39-58_screenshot.png" alt="2024-01-03_12-39-58_screenshot.png" />
</p>
</div>

<p>
r<sub>1</sub>|r<sub>2</sub>
</p>
<ul class="org-ul">
<li>this one is quite difficult, because the two expressions can overlap</li>
<li>in general they should just be combined, making sure the overlapping states are also combined
<ul class="org-ul">
<li>DFA has to be deterministic</li>
</ul></li>
</ul>

<div id="orgdcf80fb" class="figure">
<p><img src="Finite_State_Machines/2024-01-03_14-25-26_screenshot.png" alt="2024-01-03_14-25-26_screenshot.png" />
</p>
</div>

<p>
The following aren&rsquo;t possible using DFA
</p>
<ul class="org-ul">
<li><code>r+</code></li>
<li><code>r*</code></li>
<li><code>r?</code></li>
</ul>

<p>
To match these we have to use a nondeterministic finite automaton
</p>
</div>
</div>
<div id="outline-container-org0f95758" class="outline-4">
<h4 id="org0f95758"><span class="section-number-4">6.2.3.</span> Regex to Non Deterministic Finite Automaton (NFA)</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
We opt to use NFAε instead of DFA for regular expression matching
</p>
<ul class="org-ul">
<li>A lot easier to create</li>
</ul>
<p>
<code>r+</code>
<img src="Finite_State_Machines/2024-01-03_14-31-52_screenshot.png" alt="2024-01-03_14-31-52_screenshot.png" />
</p>

<p>
<code>r*</code>
<img src="Finite_State_Machines/2024-01-03_14-32-46_screenshot.png" alt="2024-01-03_14-32-46_screenshot.png" />
</p>

<p>
<code>r?</code>
<img src="Finite_State_Machines/2024-01-03_14-44-14_screenshot.png" alt="2024-01-03_14-44-14_screenshot.png" />
</p>

<p>
r<sub>1</sub>|r<sub>2</sub>
<img src="Finite_State_Machines/2024-01-03_14-46-01_screenshot.png" alt="2024-01-03_14-46-01_screenshot.png" />
</p>

<p>
r<sub>1</sub>​r<sub>2</sub>
<img src="Finite_State_Machines/2024-01-03_14-47-18_screenshot.png" alt="2024-01-03_14-47-18_screenshot.png" />
</p>

<p>
All other expression are the same as DFA
</p>
</div>
</div>
<div id="outline-container-orga5d045f" class="outline-4">
<h4 id="orga5d045f"><span class="section-number-4">6.2.4.</span> Running NFAε</h4>
<div class="outline-text-4" id="text-6-2-4">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">runNFA&#949;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">NFA&#949;</span> symbol state <span style="color: #dcaeea;">-&gt;</span> [symbol] <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Set</span> state
<span style="color: #c678dd;">runNFA&#949;</span> (<span style="color: #ECBE7B;">NFA&#949;</span> step &#949;steps genOut s0) <span style="color: #dcaeea;">=</span>
    foldr (reachable &#949;steps (s0 nfa))
          (<span style="color: #dcaeea;">\</span>symbol <span style="color: #dcaeea;">-&gt;</span> Set.unions <span style="color: #dcaeea;">.</span> Set.map
            (reachable &#949;steps <span style="color: #dcaeea;">.</span> step nfa symbol))

<span style="color: #c678dd;">reachable</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Set</span> (state,state) <span style="color: #dcaeea;">-&gt;</span> state <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Set</span> state
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">was left as an exercise, should be pretty easy with breadth first search</span>
<span style="color: #c678dd;">reachable</span> <span style="color: #dcaeea;">=</span> undefined
</pre>
</div>
</div>
</div>
<div id="outline-container-org314ca8a" class="outline-4">
<h4 id="org314ca8a"><span class="section-number-4">6.2.5.</span> Performance of the NFA regex</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
If n = length input and m = length regexp, then&#x2026;
</p>
<ul class="org-ul">
<li>\(O(nm)\) time</li>
</ul>

<p>
Best know algorithm (2009):
</p>
<ul class="org-ul">
<li>\(O(n)\) space</li>
<li>\(O(nm\frac{\log \log n}{\log^{\frac 3 2}n}+n+m)\) time</li>
</ul>
</div>
</div>
<div id="outline-container-org32cda94" class="outline-4">
<h4 id="org32cda94"><span class="section-number-4">6.2.6.</span> Converting NFAε to DFA</h4>
<div class="outline-text-4" id="text-6-2-6">
<p>
Basically just create a DFA where the state variable is a set of state
</p>

<p>
The implementation is somewhat similar to runNFA𝜀
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">runNFA&#949;</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">NFA&#949;</span> sy st <span style="color: #dcaeea;">-&gt;</span> [sy] <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Set</span> st

<span style="color: #c678dd;">runDFA</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">DFA</span> sy (<span style="color: #ECBE7B;">Set</span> st) <span style="color: #dcaeea;">-&gt;</span> [sy] <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Set</span> st
<span style="color: #c678dd;">runNFA&#949;</span> <span style="color: #dcaeea;">=</span> runDFA <span style="color: #dcaeea;">.</span> n2d

<span style="color: #c678dd;">n2d</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">NFA&#949;</span> sy st <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">DFA</span> sy (<span style="color: #ECBE7B;">Set</span> st)
<span style="color: #c678dd;">n2d</span> (<span style="color: #ECBE7B;">NFA&#949;</span> step &#949;steps genOut s0) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Moore</span>
    { s0 <span style="color: #dcaeea;">=</span> reachable &#949;steps (s0 nfa) <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">:: Set state</span>
    , step <span style="color: #dcaeea;">=</span> sy <span style="color: #dcaeea;">-&gt;</span> Set.unions <span style="color: #dcaeea;">.</span> Set.map
        (reachable &#949;steps <span style="color: #dcaeea;">.</span> step nfa sy) <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">:: symbol &#8594; Set state &#8594; Set state</span>
    , genOut <span style="color: #dcaeea;">=</span> any genOut} <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">:: Set state -&gt; Bool</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb2d9e27" class="outline-2">
<h2 id="orgb2d9e27"><span class="section-number-2">7.</span> Folding</h2>
<div class="outline-text-2" id="text-7">
<p>
A compiler roughly has the folowing phases
</p>
<ul class="org-ul">
<li>Lexing and parsing</li>
<li>Analysis and type checking</li>
<li>Desugaring</li>
<li>Optimization</li>
<li>Code generation</li>
</ul>

<p>
Abstract syntax trees play a central role:
</p>
<ul class="org-ul">
<li>Some phases build AST&rsquo;s (parsing)</li>
<li>Most phases traverse AST&rsquo;s (analysis, type checking, code generation)</li>
<li>Some phases traverse one AST and build another (desugaring)</li>
</ul>

<p>
We use folding to systematically traverse an AST
</p>
</div>
<div id="outline-container-org3249542" class="outline-3">
<h3 id="org3249542"><span class="section-number-3">7.1.</span> List folding</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Most common functions over lists can be expressed as folds
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">foldr</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> r <span style="color: #dcaeea;">-&gt;</span> r) <span style="color: #dcaeea;">-&gt;</span> r <span style="color: #dcaeea;">-&gt;</span> [a] <span style="color: #dcaeea;">-&gt;</span> r
<span style="color: #c678dd;">foldr</span> v <span style="color: #ECBE7B;">[]</span> <span style="color: #dcaeea;">=</span> v
<span style="color: #c678dd;">foldr</span> f v (x <span style="color: #ECBE7B;">:</span> xs) <span style="color: #dcaeea;">=</span> f x (foldr f v xs)

<span style="color: #c678dd;">sum</span> <span style="color: #dcaeea;">=</span> foldr (<span style="color: #dcaeea;">+</span>) <span style="color: #da8548; font-weight: bold;">0</span>

<span style="color: #c678dd;">length</span> <span style="color: #dcaeea;">=</span> foldr (<span style="color: #dcaeea;">\</span>r <span style="color: #dcaeea;">-&gt;</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #dcaeea;">+</span> r) <span style="color: #da8548; font-weight: bold;">0</span>
</pre>
</div>

<p>
We can pack the arguments to foldr into a single one, which we call <b>list algebra</b>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">ListAlgebra</span> a r <span style="color: #dcaeea;">=</span> (r, a <span style="color: #dcaeea;">&#8594;</span> r <span style="color: #dcaeea;">&#8594;</span> r)

<span style="color: #c678dd;">foldr</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ListAlgebra</span> a r <span style="color: #dcaeea;">&#8594;</span> [a] <span style="color: #dcaeea;">&#8594;</span> r
<span style="color: #c678dd;">foldr</span> (v, ) <span style="color: #ECBE7B;">[]</span> <span style="color: #dcaeea;">=</span> v
<span style="color: #c678dd;">foldr</span> (v, f) (x <span style="color: #ECBE7B;">:</span> xs) <span style="color: #dcaeea;">=</span> f x (foldr (v, f) xs)
</pre>
</div>

<p>
For example we can express map and filter as a list algebra
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">mapAlg</span> <span style="color: #dcaeea;">::</span> (a<span style="color: #dcaeea;">-&gt;</span>b) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">ListAlgebra</span> a [b]
<span style="color: #c678dd;">mapAlg</span> f <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">[]</span>, <span style="color: #dcaeea;">\</span>a bs <span style="color: #dcaeea;">-&gt;</span> f a <span style="color: #ECBE7B;">:</span> bs)

<span style="color: #c678dd;">filterAlg</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Bool</span>) <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">ListAlgebra</span> a [a]
<span style="color: #c678dd;">filterAlg</span> f <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">[]</span>, <span style="color: #dcaeea;">\</span>x xs <span style="color: #dcaeea;">-&gt;</span> <span style="color: #51afef;">if</span> f x <span style="color: #51afef;">then</span> x <span style="color: #ECBE7B;">:</span> xs <span style="color: #51afef;">else</span> xs)
</pre>
</div>
</div>
</div>
<div id="outline-container-org424f031" class="outline-3">
<h3 id="org424f031"><span class="section-number-3">7.2.</span> Matched parentheses</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Consider a grammer with corresponding data type
</p>
<ul class="org-ul">
<li>\(S\rightarrow (S)S|\epsilon\)</li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Parens</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Match</span> <span style="color: #ECBE7B;">Parens</span> <span style="color: #ECBE7B;">Parens</span>
            <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Empty</span>
</pre>
</div>

<p>
Consider two functions:
</p>
<ul class="org-ul">
<li>One counts the number of pairs</li>
<li>One gets the maximal nesting depth</li>
</ul>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">count</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parens</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">count</span> (<span style="color: #ECBE7B;">Match</span> p1 p2) <span style="color: #dcaeea;">=</span> (count p1 <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #dcaeea;">+</span> count p2
<span style="color: #c678dd;">count</span> <span style="color: #ECBE7B;">Empty</span> <span style="color: #dcaeea;">=</span> <span style="color: #da8548; font-weight: bold;">0</span>

<span style="color: #c678dd;">depth</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parens</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">depth</span> (<span style="color: #ECBE7B;">Match</span> p1 p2) <span style="color: #dcaeea;">=</span> (depth p1 <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #dcaeea;">`max`</span> depth p2
<span style="color: #c678dd;">depth</span> <span style="color: #ECBE7B;">Empty</span> <span style="color: #dcaeea;">=</span> <span style="color: #da8548; font-weight: bold;">0</span>
</pre>
</div>

<p>
Both these functions have the following structure:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">f</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Parens</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">...</span>
<span style="color: #c678dd;">f</span> (<span style="color: #ECBE7B;">Match</span> p1 p2) <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">...</span> (f p1) (f p2)
<span style="color: #c678dd;">f</span> <span style="color: #ECBE7B;">Empty</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">...</span>
</pre>
</div>

<p>
We can define a fold algebra like this
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">ParensAlgebra</span> r <span style="color: #dcaeea;">=</span> (r <span style="color: #dcaeea;">-&gt;</span> r <span style="color: #dcaeea;">-&gt;</span> r, <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">match</span>
                        r) <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">empty</span>

<span style="color: #c678dd;">foldParens</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ParensAlgebra</span> r <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Parens</span> <span style="color: #dcaeea;">-&gt;</span> r
<span style="color: #c678dd;">foldParens</span> (match, empty) <span style="color: #dcaeea;">=</span> f
    <span style="color: #51afef;">where</span> f (<span style="color: #ECBE7B;">Match</span> p1 p2) <span style="color: #dcaeea;">=</span> match (f p1) (f p2)
        f <span style="color: #ECBE7B;">Empty</span> <span style="color: #dcaeea;">=</span> empty
</pre>
</div>

<p>
Now we can redefine the functions using a fold:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">countAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ParensAlgebra</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">countAlgebra</span> <span style="color: #dcaeea;">=</span> (<span style="color: #dcaeea;">\</span>c1 c2 <span style="color: #dcaeea;">-&gt;</span> c1 <span style="color: #dcaeea;">+</span> c2 <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>)
<span style="color: #c678dd;">count</span> <span style="color: #dcaeea;">=</span> foldParens countAlgebra

<span style="color: #c678dd;">depthAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ParensAlgebra</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">depthAlgebra</span> <span style="color: #dcaeea;">=</span> (<span style="color: #dcaeea;">\</span>d1 d2 <span style="color: #dcaeea;">-&gt;</span> (d1 <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #dcaeea;">`max`</span> d2, <span style="color: #da8548; font-weight: bold;">0</span>)
<span style="color: #c678dd;">depth</span> <span style="color: #dcaeea;">=</span> foldParens depthAlgebra

<span style="color: #c678dd;">printAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ParensAlgebra</span> <span style="color: #ECBE7B;">String</span>
<span style="color: #c678dd;">printAlgebra</span> <span style="color: #dcaeea;">=</span> (<span style="color: #dcaeea;">\</span>p1 p2 <span style="color: #dcaeea;">-&gt;</span> <span style="color: #98be65;">"("</span> <span style="color: #dcaeea;">++</span> p1 <span style="color: #dcaeea;">++</span> <span style="color: #98be65;">")"</span> <span style="color: #dcaeea;">++</span> p2, <span style="color: #98be65;">""</span>)
<span style="color: #c678dd;">print</span> <span style="color: #dcaeea;">=</span> foldParens printAlgebra
</pre>
</div>
</div>
</div>
<div id="outline-container-org149455e" class="outline-3">
<h3 id="org149455e"><span class="section-number-3">7.3.</span> Arithmetic expressions</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Lets take a simple grammar for arithmetic expressions
</p>
<ul class="org-ul">
<li>\(E → E + E\)</li>
<li>\(E → - E\)</li>
<li>\(E → Nat\)</li>
<li>\(E → ( E )\)</li>
</ul>

<p>
We convert it to the following grammar because of operator associativity
</p>
<ul class="org-ul">
<li>\(E → E' + E | E'\)</li>
<li>\(E' → - E'\)</li>
<li>\(E' → Nat\)</li>
<li>\(E' → ( E )\)</li>
</ul>

<p>
The haskell data type is based on the orginal grammar
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Add</span> <span style="color: #ECBE7B;">E</span> <span style="color: #ECBE7B;">E</span>
       <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Neg</span> <span style="color: #ECBE7B;">E</span>
       <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Num</span> <span style="color: #ECBE7B;">Int</span>
</pre>
</div>

<p>
The structures/types of the function reflects the structure of the datatype.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ECBE7B;">Add</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #ECBE7B;">Neg</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #ECBE7B;">Num</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>

<span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">EAlgebra</span> r <span style="color: #dcaeea;">=</span> (r <span style="color: #dcaeea;">-&gt;</span> r <span style="color: #dcaeea;">-&gt;</span> r, <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">add</span>
                   r <span style="color: #dcaeea;">-&gt;</span> r, <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">neg</span>
                   <span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> r) <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">num</span>
</pre>
</div>

<p>
With the algebra we define a fold
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">foldE</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">EAlgebra</span> r <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> r
<span style="color: #c678dd;">foldE</span> (add, neg, num) <span style="color: #dcaeea;">=</span> f
    <span style="color: #51afef;">where</span> f (<span style="color: #ECBE7B;">Add</span> e1 e2) <span style="color: #dcaeea;">=</span> add (f e1) (f e2)
          f (<span style="color: #ECBE7B;">Neg</span> e) <span style="color: #dcaeea;">=</span> neg (f e)
          f (<span style="color: #ECBE7B;">Num</span> n) <span style="color: #dcaeea;">=</span> num n
</pre>
</div>

<p>
Using this fold we can create an evaluation function for the expression data type
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">evalAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">EAlgebra</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">evalAlgebra</span> <span style="color: #dcaeea;">=</span> ((<span style="color: #dcaeea;">+</span>), negate, id)

<span style="color: #c678dd;">eval</span> <span style="color: #dcaeea;">=</span> foldE evalAlgebra
</pre>
</div>
</div>
</div>
<div id="outline-container-orga3b57dd" class="outline-3">
<h3 id="orga3b57dd"><span class="section-number-3">7.4.</span> Building a fold for any datatype</h3>
<div class="outline-text-3" id="text-7-4">
<p>
For a datatype T, we can define a fold function as follows:
</p>
<ul class="org-ul">
<li>Define an algebra type TAlgebra that is based on all of T’s parameters, plus a result type r.</li>
<li>The algebra is a tuple containing one component per constructor function
<ul class="org-ul">
<li>You could also use the record syntax, to give each component a name</li>
</ul></li>
<li>The types of the components are like the types of the constructor functions, but all occurrences of T are replaced with r, the result type.</li>
<li>The fold function is defined by traversing the data structure, replacing constructors with their corresponding algebra components, and recursing where required.</li>
</ul>

<p>
Every datatype has an <b>identity algebra</b>, which arises by using the constructors as components of the algebra.
</p>
</div>
<div id="outline-container-orgc60395e" class="outline-4">
<h4 id="orgc60395e"><span class="section-number-4">7.4.1.</span> Trees example</h4>
<div class="outline-text-4" id="text-7-4-1">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Tree</span> a <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Leaf</span> a
            <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Node</span> (<span style="color: #ECBE7B;">Tree</span> a) (<span style="color: #ECBE7B;">Tree</span> a)

<span style="color: #ECBE7B;">Leaf</span> <span style="color: #dcaeea;">::</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Tree</span> a
<span style="color: #ECBE7B;">Node</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Tree</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Tree</span> a <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Tree</span> a

<span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">TreeAlgebra</span> a r <span style="color: #dcaeea;">=</span> (a <span style="color: #dcaeea;">-&gt;</span> r, <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">leaf</span>
                        r <span style="color: #dcaeea;">-&gt;</span> r <span style="color: #dcaeea;">-&gt;</span> r) <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">node</span>

<span style="color: #c678dd;">foldTree</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">TreeAlgebra</span> a r <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Tree</span> a <span style="color: #dcaeea;">-&gt;</span> r
<span style="color: #c678dd;">foldTree</span> (leaf, node) <span style="color: #dcaeea;">=</span> f
    <span style="color: #51afef;">where</span> f (<span style="color: #ECBE7B;">Leaf</span> x) <span style="color: #dcaeea;">=</span> leaf x
        f (<span style="color: #ECBE7B;">Node</span> l r) <span style="color: #dcaeea;">=</span> node (f l) (f r)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">sizeAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">TreeAlgebra</span> a <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">sizeAlgebra</span> <span style="color: #dcaeea;">=</span> (const <span style="color: #da8548; font-weight: bold;">1</span>, (<span style="color: #dcaeea;">+</span>))

<span style="color: #c678dd;">sumAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">TreeAlgebra</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">sumAlgebra</span> <span style="color: #dcaeea;">=</span> (id, (<span style="color: #dcaeea;">+</span>))

<span style="color: #c678dd;">inorderAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">TreeAlgebra</span> a [a]
<span style="color: #c678dd;">inorderAlgebra</span> <span style="color: #dcaeea;">=</span> ((<span style="color: #ECBE7B;">:[]</span>), <span style="color: #dcaeea;">++</span>)

<span style="color: #c678dd;">reverseAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">TreeAlgebra</span> a (<span style="color: #ECBE7B;">Tree</span> a)
<span style="color: #c678dd;">reverseAlgebra</span> <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">Leaf</span>, flip <span style="color: #ECBE7B;">Node</span>)

<span style="color: #c678dd;">idAlgebra</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">TreeAlgebra</span> a (<span style="color: #ECBE7B;">Tree</span> a)
<span style="color: #c678dd;">idAlgebra</span> <span style="color: #dcaeea;">=</span> (<span style="color: #ECBE7B;">Leaf</span>, <span style="color: #ECBE7B;">Node</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3ca4b42" class="outline-3">
<h3 id="org3ca4b42"><span class="section-number-3">7.5.</span> <span class="todo TODO">TODO</span> Fix</h3>
<div class="outline-text-3" id="text-7-5">
<p>
Dit leek me niet super nuttig, misschien later samenvatten.
</p>

<p>
Het is een manier om nog verder te abstracten op de algemene structuur van folds enzo
<img src="Folding/2024-01-07_17-33-57_screenshot.png" alt="2024-01-07_17-33-57_screenshot.png" />
<img src="Folding/2024-01-07_17-34-09_screenshot.png" alt="2024-01-07_17-34-09_screenshot.png" />
</p>
</div>
</div>
<div id="outline-container-orgff06400" class="outline-3">
<h3 id="orgff06400"><span class="section-number-3">7.6.</span> Algebra for families of datatypes</h3>
<div class="outline-text-3" id="text-7-6">
<p>
Each datatype in the family can have its own result type.
</p>

<p>
<i>example:</i>
</p>

<p>
Result type e for expressions, result type d for declarations
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ECBE7B;">Add</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #ECBE7B;">Neg</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #ECBE7B;">Num</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #ECBE7B;">Var</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Id</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #ECBE7B;">Def</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">D</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span>
<span style="color: #ECBE7B;">Dcl</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Id</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">D</span>

<span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">EDAlgebra</span> e d <span style="color: #dcaeea;">=</span>
    (e <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> e,
    e <span style="color: #dcaeea;">-&gt;</span> e,
    <span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> e,
    <span style="color: #ECBE7B;">Id</span> <span style="color: #dcaeea;">-&gt;</span> e,
    d <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> e,
    <span style="color: #ECBE7B;">Id</span> <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> d)
</pre>
</div>

<p>
We also need one function per type to traverse the structure:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">foldE</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">EDAlgebra</span> e d <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> e
<span style="color: #c678dd;">foldE</span> (add, neg, num, var, def, dcl) <span style="color: #dcaeea;">=</span> fe
    <span style="color: #51afef;">where</span> fe (<span style="color: #ECBE7B;">Add</span> e1 e2) <span style="color: #dcaeea;">=</span> add (fe e1) (fe e2)
        fe (<span style="color: #ECBE7B;">Neg</span> e) <span style="color: #dcaeea;">=</span> neg (fe e)
        fe (<span style="color: #ECBE7B;">Num</span> n) <span style="color: #dcaeea;">=</span> num n
        fe (<span style="color: #ECBE7B;">Var</span> x) <span style="color: #dcaeea;">=</span> var x
        fe (<span style="color: #ECBE7B;">Def</span> d e) <span style="color: #dcaeea;">=</span> def (fd d) (fe e)
        fd (<span style="color: #ECBE7B;">Dcl</span> x e) <span style="color: #dcaeea;">=</span> dcl x (fe e)

<span style="color: #c678dd;">fe</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> e
<span style="color: #c678dd;">fd</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">D</span> <span style="color: #dcaeea;">-&gt;</span> d
</pre>
</div>

<p>
We can also add a list type to one of the constructors:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">...</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Def</span> [<span style="color: #ECBE7B;">D</span>] <span style="color: #ECBE7B;">E</span> <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">modified</span>

<span style="color: #5B6268;">--  </span><span style="color: #5B6268;">We keep the list in the algebra</span>
<span style="color: #51afef;">type</span> <span style="color: #ECBE7B;">EDAlgebra</span> e d <span style="color: #dcaeea;">=</span>
    ( <span style="color: #dcaeea;">...</span>,
    [d] <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> e,
    <span style="color: #dcaeea;">...</span>)

<span style="color: #c678dd;">foldE</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">EDAlgebra</span> e d <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">E</span> <span style="color: #dcaeea;">-&gt;</span> e
<span style="color: #c678dd;">foldE</span> (add, neg, num, var, def, dcl) <span style="color: #dcaeea;">=</span> fe
    <span style="color: #51afef;">where</span> <span style="color: #dcaeea;">...</span>
          fe (<span style="color: #ECBE7B;">Def</span> ds e) <span style="color: #dcaeea;">=</span> def (map fd ds) (fe e)
          <span style="color: #dcaeea;">...</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgebc4ee4" class="outline-3">
<h3 id="orgebc4ee4"><span class="section-number-3">7.7.</span> RepMax fold</h3>
<div class="outline-text-3" id="text-7-7">
<p>
RepMax replaces all the elements of a list with the largest number.
</p>

<p>
We use this function as an example of a sort of &rsquo;recursive&rsquo; fold
</p>
<ul class="org-ul">
<li>You have to now the max before you can fold the list</li>
</ul>

<p>
It can be implemented using two folds:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">maxAlg</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ListAlgebra</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">maxAlg</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">LAlg</span> {nil <span style="color: #dcaeea;">=</span> minBound, cons x m <span style="color: #dcaeea;">=</span> x &#8216;maximum&#8216; m}
<span style="color: #c678dd;">repAlg</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">ListAlgebra</span> <span style="color: #ECBE7B;">Int</span> [<span style="color: #ECBE7B;">Int</span>]
<span style="color: #c678dd;">repAlg</span> m <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">LAlg</span> {nil <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">[]</span>, cons xs <span style="color: #dcaeea;">=</span> m <span style="color: #ECBE7B;">:</span> xs}
<span style="color: #c678dd;">repMax</span> xs <span style="color: #dcaeea;">=</span> foldr repAlg (foldr maxAlg xs) xs
</pre>
</div>

<p>
It can be implemented using a single fold
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">repMaxAlg</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ListAlgebra</span> <span style="color: #ECBE7B;">Int</span> (<span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> ([<span style="color: #ECBE7B;">Int</span>], <span style="color: #ECBE7B;">Int</span>))
<span style="color: #c678dd;">repMaxAlg</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">LAlg</span> {nil <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>max <span style="color: #dcaeea;">-&gt;</span> (<span style="color: #ECBE7B;">[]</span>, minBound)
    , cons x f <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>max <span style="color: #dcaeea;">-&gt;</span>
        <span style="color: #51afef;">let</span> (ys, maxSoFar) <span style="color: #dcaeea;">=</span> f max
        <span style="color: #51afef;">in</span> (max <span style="color: #ECBE7B;">:</span> ys, x &#8216;maximum&#8216; maxSoFar)}

<span style="color: #c678dd;">repMax</span> <span style="color: #dcaeea;">::</span> [<span style="color: #ECBE7B;">Int</span>] <span style="color: #dcaeea;">-&gt;</span> [<span style="color: #ECBE7B;">Int</span>]
<span style="color: #c678dd;">repMax</span> xs <span style="color: #dcaeea;">=</span> maxs
    <span style="color: #51afef;">where</span> (maxs, max) <span style="color: #dcaeea;">=</span> foldr repMaxAlg xs max
</pre>
</div>

<p>
Note the recursion in the last line, we the result of the function to the actual function, this can be done in haskell because magic and laziness and stuff.
</p>
</div>
</div>
</div>
<div id="outline-container-org531965f" class="outline-2">
<h2 id="org531965f"><span class="section-number-2">8.</span> Simple Stack Machine</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org55565f6" class="outline-3">
<h3 id="org55565f6"><span class="section-number-3">8.1.</span> Documentation</h3>
<div class="outline-text-3" id="text-8-1">
<p>
A lot more detailed documentation can be found on the SSM page:
</p>
<ul class="org-ul">
<li><a href="https://ics.uu.nl/docs/vakken/b3tc/SSM/">Simple Stack Machine homepage</a></li>
<li><a href="https://ics.uu.nl/docs/vakken/b3tc/SSM/ssmtopics.html#add">Simple Stack Machine Instruction Set</a></li>
</ul>
</div>
</div>
<div id="outline-container-org1a01c34" class="outline-3">
<h3 id="org1a01c34"><span class="section-number-3">8.2.</span> Architecture</h3>
<div class="outline-text-3" id="text-8-2">
<p>
The simple stack machine is a virtual machine that executes programs consisting of assembly language instructions
</p>

<p>
The program is a list of instructions with arguments, stored in a continuous block of memory.
</p>

<p>
A <b>stack</b> is used to store the current state of execution
</p>

<p>
There are eight <b>registers</b>, four with a special name:
</p>
<ul class="org-ul">
<li><b>program counter (PC)</b></li>
<li><b>stack pointer (SP)</b></li>
<li><b>mark pointer (MP)</b></li>
<li><b>return register (RR)</b></li>
</ul>

<p>
A step in the execution interprets the instruction pointed to by the program counter.
</p>

<p>
Depending on the instruction, the contents of the stack and registers are modified.
</p>
</div>
</div>
<div id="outline-container-org6c794b3" class="outline-3">
<h3 id="org6c794b3"><span class="section-number-3">8.3.</span> Instructions</h3>
<div class="outline-text-3" id="text-8-3">
</div>
<div id="outline-container-org42d807e" class="outline-4">
<h4 id="org42d807e"><span class="section-number-4">8.3.1.</span> <code>LDC</code> - load constant</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
Pushes the inline constant on the stack.
</p>
</div>
</div>
<div id="outline-container-org01d762e" class="outline-4">
<h4 id="org01d762e"><span class="section-number-4">8.3.2.</span> <code>LDR</code> - load from register</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
Pushes a value from a register onto the stack.
</p>
</div>
</div>
<div id="outline-container-orga579b7c" class="outline-4">
<h4 id="orga579b7c"><span class="section-number-4">8.3.3.</span> <code>LDL</code> - loal local</h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
Pushes a value relative to the markpointer register.
</p>

<p>
<i>Example:</i>
</p>

<p>
Before:
</p>

<div id="orga5a91fa" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_18-11-36_screenshot.png" alt="2024-01-07_18-11-36_screenshot.png" />
</p>
</div>

<p>
after
</p>


<div id="orgeb251a0" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_18-12-24_screenshot.png" alt="2024-01-07_18-12-24_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgcc57093" class="outline-4">
<h4 id="orgcc57093"><span class="section-number-4">8.3.4.</span> <code>LDS</code> - load from stack</h4>
<div class="outline-text-4" id="text-8-3-4">
<p>
Pushes a value relative to the top of the stack.
</p>

<p>
<i>example:</i>
</p>

<p>
before:
</p>


<div id="org731b517" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_18-13-50_screenshot.png" alt="2024-01-07_18-13-50_screenshot.png" />
</p>
</div>

<p>
after:
</p>


<div id="org5ce696f" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_18-14-45_screenshot.png" alt="2024-01-07_18-14-45_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org854ce0e" class="outline-4">
<h4 id="org854ce0e"><span class="section-number-4">8.3.5.</span> <code>LDLA</code> - load local adress</h4>
<div class="outline-text-4" id="text-8-3-5">
<p>
Pushes the address of a value relative to the markpointer.
</p>

<p>
There seems to be a mistake in the example of the slides so it is not included here
</p>
</div>
</div>
<div id="outline-container-orgadd13b0" class="outline-4">
<h4 id="orgadd13b0"><span class="section-number-4">8.3.6.</span> <code>LDA</code> - load via adress</h4>
<div class="outline-text-4" id="text-8-3-6">
<p>
Pushes the value pointed to by the value at the top of the stack. The pointer value is offset by a constant offset.
</p>

<p>
Once again slides examples seem to be incorrect
</p>
</div>
</div>
<div id="outline-container-org2c5445a" class="outline-4">
<h4 id="org2c5445a"><span class="section-number-4">8.3.7.</span> <code>LDRR</code> - load register from register</h4>
<div class="outline-text-4" id="text-8-3-7">
<p>
Copy the content of the second register to the first. Does not affect the stack.
</p>

<p>
<i>examples:</i>
</p>

<p>
before:
</p>


<div id="org6437982" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_19-22-01_screenshot.png" alt="2024-01-07_19-22-01_screenshot.png" />
</p>
</div>

<p>
after:
</p>


<div id="orgd219341" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_19-22-37_screenshot.png" alt="2024-01-07_19-22-37_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org253fee1" class="outline-4">
<h4 id="org253fee1"><span class="section-number-4">8.3.8.</span> <code>NOP</code> - noop</h4>
<div class="outline-text-4" id="text-8-3-8">
<p>
No operation, does nothing, goes to next instruction.
</p>
</div>
</div>
<div id="outline-container-org8a282f2" class="outline-4">
<h4 id="org8a282f2"><span class="section-number-4">8.3.9.</span> <code>HALT</code> - halt program</h4>
<div class="outline-text-4" id="text-8-3-9">
<p>
Machine stops executing instructions.
</p>
</div>
</div>
<div id="outline-container-orgffa501a" class="outline-4">
<h4 id="orgffa501a"><span class="section-number-4">8.3.10.</span> <code>AJS</code> - adjust stack pointer</h4>
<div class="outline-text-4" id="text-8-3-10">
<p>
Adjusts the stackpointer with fixed amount.
</p>

<p>
<i>example:</i>
</p>

<p>
begin:
</p>


<div id="org9e5d9c4" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_19-25-42_screenshot.png" alt="2024-01-07_19-25-42_screenshot.png" />
</p>
</div>

<p>
after:
</p>


<div id="org37183d2" class="figure">
<p><img src="Simple_stack_machine/2024-01-07_19-26-59_screenshot.png" alt="2024-01-07_19-26-59_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc5ccd77" class="outline-4">
<h4 id="orgc5ccd77"><span class="section-number-4">8.3.11.</span> <code>BRA</code> - unconditional branch</h4>
<div class="outline-text-4" id="text-8-3-11">
<p>
Jumps to the destination. Replaces the PC with the destination address.
</p>
</div>
</div>
<div id="outline-container-org5f2207e" class="outline-4">
<h4 id="org5f2207e"><span class="section-number-4">8.3.12.</span> <code>BSR</code> - branch to subroutine</h4>
<div class="outline-text-4" id="text-8-3-12">
<p>
Pushes the PC on the stack and jumps to the subroutine.
</p>

<p>
<i>example:</i>
</p>

<p>
before:
</p>


<div id="org7939821" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_11-50-30_screenshot.png" alt="2024-01-08_11-50-30_screenshot.png" />
</p>
</div>

<p>
after:
</p>


<div id="org678aeaa" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_11-51-16_screenshot.png" alt="2024-01-08_11-51-16_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgf87a547" class="outline-4">
<h4 id="orgf87a547"><span class="section-number-4">8.3.13.</span> <code>RET</code> - return from subroutine</h4>
<div class="outline-text-4" id="text-8-3-13">
<p>
Pops a previously pushed PC from the stack and jumps to it.
</p>

<p>
<i>example:</i>
</p>

<p>
before:
</p>


<div id="orgf9dd479" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_11-56-40_screenshot.png" alt="2024-01-08_11-56-40_screenshot.png" />
</p>
</div>

<p>
after:
</p>


<div id="org92eb9fd" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_11-57-05_screenshot.png" alt="2024-01-08_11-57-05_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org9b26fdd" class="outline-4">
<h4 id="org9b26fdd"><span class="section-number-4">8.3.14.</span> <code>STR</code> - store to register</h4>
<div class="outline-text-4" id="text-8-3-14">
<p>
Pops a value from the stack and stores it in the specified register. See also ldr.
</p>
</div>
</div>
<div id="outline-container-org725e591" class="outline-4">
<h4 id="org725e591"><span class="section-number-4">8.3.15.</span> <code>STS</code> - store into stack</h4>
<div class="outline-text-4" id="text-8-3-15">
<p>
Pops a value from the stack and stores it in a location relative to the top of the stack.
</p>
</div>
</div>
<div id="outline-container-org3e230a7" class="outline-4">
<h4 id="org3e230a7"><span class="section-number-4">8.3.16.</span> <code>STL</code> - store local</h4>
<div class="outline-text-4" id="text-8-3-16">
<p>
Pops a value from the stack and stores it in a location relative to the markpointer.
</p>
</div>
</div>
<div id="outline-container-org2e1cff1" class="outline-4">
<h4 id="org2e1cff1"><span class="section-number-4">8.3.17.</span> Operators</h4>
<div class="outline-text-4" id="text-8-3-17">
<p>
Operators remove stack arguments and put the result back on the stack.
</p>

<p>
Binary operators:
</p>
<ul class="org-ul">
<li><code>ADD</code> - Addition</li>
<li><code>SUB</code> - Substraction</li>
<li><code>MUL</code> - Multiplication</li>
<li><code>DIV</code> - Division</li>
<li><code>MOD</code> - Modulo</li>
<li><code>AND</code> - Bitwise And</li>
<li><code>OR</code> - Bitwise Or</li>
<li><code>XOR</code> - Bitwise Exclusive Or</li>
<li><code>EQ</code> - Test for equal, false is encoded as 0, true as 1</li>
<li><code>NE</code> - Test for not equal, false is encoded as 0, true as 1</li>
<li><code>LT</code> - Test for less then, false is encoded as 0, true as 1</li>
<li><code>GT</code> - Test for greater then, false is encoded as 0, true as 1</li>
<li><code>LE</code> - Test for less then or equals, false is encoded as 0, true as 1</li>
<li><code>GE</code> - Test for greater then or equals, false is encoded as 0, true as 1</li>
</ul>

<p>
Unary operators:
</p>
<ul class="org-ul">
<li><code>NOT</code> - Bitwise complement of the value</li>
<li><code>NEG</code> - Integer negation</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org6e596d9"></a>Binary Operator Example:<br />
<div class="outline-text-5" id="text-8-3-17-1">
<p>
4 and 7 are on top of the stack
</p>


<div id="org8fb39d8" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_12-16-23_screenshot.png" alt="2024-01-08_12-16-23_screenshot.png" />
</p>
</div>

<p>
<code>MUL</code> is called, 4 and 7 are popped from the stack, the result 28 is pushed on to the stack.
<img src="Simple_stack_machine/2024-01-08_12-18-01_screenshot.png" alt="2024-01-08_12-18-01_screenshot.png" />
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org8f27475" class="outline-3">
<h3 id="org8f27475"><span class="section-number-3">8.4.</span> Translating programs</h3>
<div class="outline-text-3" id="text-8-4">
</div>
<div id="outline-container-orge6f7250" class="outline-4">
<h4 id="orge6f7250"><span class="section-number-4">8.4.1.</span> Translating expressions</h4>
<div class="outline-text-4" id="text-8-4-1">
</div>
<ol class="org-ol">
<li><a id="org5f6652f"></a>Translating simple expressions<br />
<div class="outline-text-5" id="text-8-4-1-1">
<p>
t
\[3+4*7+2\]
</p>

<p>
Can be translated into:
</p>

<div class="org-src-container">
<pre class="src src-ssm">LDC 3
LDC 4
LDC 7
MUL
ADD
LDC 2
ADD
</pre>
</div>

<p>
The translation can be done is haskell:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Num</span> <span style="color: #ECBE7B;">Int</span>
          <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Add</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Expr</span>
          <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Mul</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Expr</span>
          <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Neg</span> <span style="color: #ECBE7B;">Expr</span>
          <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Eq</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Expr</span>

<span style="color: #c678dd;">code</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Code</span>
<span style="color: #c678dd;">code</span> (<span style="color: #ECBE7B;">Num</span> n) <span style="color: #dcaeea;">=</span> [<span style="color: #ECBE7B;">LDC</span> n]
<span style="color: #c678dd;">code</span> (<span style="color: #ECBE7B;">Add</span> e1 e2) <span style="color: #dcaeea;">=</span> code e1 <span style="color: #dcaeea;">++</span> code e2 <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">ADD</span>]
<span style="color: #c678dd;">code</span> (<span style="color: #ECBE7B;">Mul</span> e1 e2) <span style="color: #dcaeea;">=</span> code e1 <span style="color: #dcaeea;">++</span> code e2 <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">MUL</span>]
<span style="color: #c678dd;">code</span> (<span style="color: #ECBE7B;">Neg</span> e) <span style="color: #dcaeea;">=</span> code e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">NEG</span>]
<span style="color: #c678dd;">code</span> (<span style="color: #ECBE7B;">Eq</span> e1 e2) <span style="color: #dcaeea;">=</span> code e1 <span style="color: #dcaeea;">++</span> code e2 <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">EQ</span>]
</pre>
</div>

<p>
The translation can also be done using a fold with a special algebra:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">code</span> x <span style="color: #dcaeea;">=</span> foldExpr codeAlg x
  <span style="color: #51afef;">where</span>
    codeAlg <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ExprAlg</span> <span style="color: #ECBE7B;">Code</span>
    codeAlg <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">ExprAlg</span>
        { num <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>n   <span style="color: #dcaeea;">-&gt;</span> [<span style="color: #ECBE7B;">LDC</span> n]
        , add <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l r <span style="color: #dcaeea;">-&gt;</span> l <span style="color: #dcaeea;">++</span> r <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">ADD</span>]
        , neg <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l   <span style="color: #dcaeea;">-&gt;</span> l <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">NEG</span>]
        , eq  <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l r <span style="color: #dcaeea;">-&gt;</span> l <span style="color: #dcaeea;">++</span> r <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">EQ</span>]
        }
</pre>
</div>
</div>
</li>
<li><a id="org72360cc"></a>Conditionals<br />
<div class="outline-text-5" id="text-8-4-1-2">
<p>
Conditionals can be translated like this:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">...</span> <span style="color: #dcaeea;">|</span>
            <span style="color: #ECBE7B;">If</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Expr</span>

<span style="color: #c678dd;">code</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Code</span>
<span style="color: #c678dd;">code</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">.</span> <span style="color: #dcaeea;">.</span> <span style="color: #dcaeea;">.</span>
<span style="color: #c678dd;">code</span> (<span style="color: #ECBE7B;">If</span> c t f) <span style="color: #dcaeea;">=</span> cc <span style="color: #dcaeea;">++</span>
                  [<span style="color: #ECBE7B;">BRF</span> (st <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">2</span>)] <span style="color: #dcaeea;">++</span>
                  ct <span style="color: #dcaeea;">++</span>
                  [<span style="color: #ECBE7B;">BRA</span> sf] <span style="color: #dcaeea;">++</span>
                  cf
    <span style="color: #51afef;">where</span> cc <span style="color: #dcaeea;">=</span> code c
          ct <span style="color: #dcaeea;">=</span> code t
          cf <span style="color: #dcaeea;">=</span> code f
          st <span style="color: #dcaeea;">=</span> codeSize ct
          sf <span style="color: #dcaeea;">=</span> codeSize cf
</pre>
</div>


<div id="org1e458f6" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_13-36-11_screenshot.png" alt="2024-01-08_13-36-11_screenshot.png" />
</p>
</div>

<p>
Once again it can be expressed using a fold and an algebra:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">code</span> x <span style="color: #dcaeea;">=</span> foldExpr codeAlg x
    <span style="color: #51afef;">where</span>
        codeAlg <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ExprAlg</span> <span style="color: #ECBE7B;">Code</span>
        codeAlg <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">ExprAlg</span>
            { num <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>n <span style="color: #dcaeea;">-&gt;</span> [<span style="color: #ECBE7B;">LDC</span> n]
            , add <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l r <span style="color: #dcaeea;">-&gt;</span> l <span style="color: #dcaeea;">++</span> r <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">ADD</span>]
            , neg <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l <span style="color: #dcaeea;">-&gt;</span> l <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">NEG</span>]
            , eq <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l r <span style="color: #dcaeea;">-&gt;</span> l <span style="color: #dcaeea;">++</span> r <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">EQ</span>]
            , <span style="color: #51afef;">if</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>c t f <span style="color: #dcaeea;">-&gt;</span>
                <span style="color: #51afef;">let</span> st <span style="color: #dcaeea;">=</span> codeSize t
                    sf <span style="color: #dcaeea;">=</span> codeSize f
                <span style="color: #51afef;">in</span> c <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">BRF</span> (st <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">2</span>)] <span style="color: #dcaeea;">++</span> t <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">BRA</span> sf] <span style="color: #dcaeea;">++</span> f
            }
</pre>
</div>
</div>
</li>
<li><a id="org34963b0"></a>Variables and environments<br />
<div class="outline-text-5" id="text-8-4-1-3">
<p>
To add variables to the code, we change the type of the code, to include an environment as an argument.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">...</span>
          <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Var</span> <span style="color: #ECBE7B;">String</span>
          <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Let</span> <span style="color: #ECBE7B;">String</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Expr</span>

<span style="color: #c678dd;">code</span> x <span style="color: #dcaeea;">=</span> foldExpr codeAlg x empty
    <span style="color: #51afef;">where</span>
    codeAlg <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">ExprAlg</span> (<span style="color: #ECBE7B;">Env</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Code</span>)
    codeAlg <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">ExprAlg</span>
        { num <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>n <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">\</span>e <span style="color: #dcaeea;">-&gt;</span> [<span style="color: #ECBE7B;">LDC</span> n]
        , add <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l r <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">\</span>e <span style="color: #dcaeea;">-&gt;</span> l e <span style="color: #dcaeea;">++</span> r e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">ADD</span>]
        , neg <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">\</span>e <span style="color: #dcaeea;">-&gt;</span> l e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">NEG</span>]
        , eq <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>l r <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">\</span>e <span style="color: #dcaeea;">-&gt;</span> l e <span style="color: #dcaeea;">++</span> r e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">EQ</span>]
        , <span style="color: #51afef;">if</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>c t f <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">\</span>e <span style="color: #dcaeea;">-&gt;</span>
            <span style="color: #51afef;">let</span> st <span style="color: #dcaeea;">=</span> codeSize (t e)
                sf <span style="color: #dcaeea;">=</span> codeSize (f e)
            <span style="color: #51afef;">in</span> c e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">BRF</span> (st <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">2</span>)] <span style="color: #dcaeea;">++</span>
               t e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">BRA</span> sf] <span style="color: #dcaeea;">++</span> f e
        , var <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>s <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">\</span>e <span style="color: #dcaeea;">-&gt;</span> [<span style="color: #ECBE7B;">LDL</span> (e <span style="color: #dcaeea;">!</span> s)]
        , leT <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>s d b <span style="color: #dcaeea;">-&gt;</span> <span style="color: #dcaeea;">\</span>e <span style="color: #dcaeea;">-&gt;</span> d e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">STL</span> (size e)]
                        <span style="color: #dcaeea;">++</span> b (insert s (size e) e)
        }
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgab856a9" class="outline-4">
<h4 id="orgab856a9"><span class="section-number-4">8.4.2.</span> Statements</h4>
<div class="outline-text-4" id="text-8-4-2">
<p>
We extend our lanuage with statements:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Stmt</span> <span style="color: #dcaeea;">=</span>
    <span style="color: #ECBE7B;">Assign</span> <span style="color: #ECBE7B;">String</span> <span style="color: #ECBE7B;">Expr</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">If</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Stmt</span> <span style="color: #ECBE7B;">Stmt</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">While</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Stmt</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Call</span> <span style="color: #ECBE7B;">String</span> [<span style="color: #ECBE7B;">Expr</span>]
</pre>
</div>

<p>
For many languages, the following invariants hold:
</p>
<ul class="org-ul">
<li>Expressions always leave a single result on the stack after evaluation</li>
<li>Statements do not leave a result on the stack after evaluation</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgda1155d"></a>While loops<br />
<div class="outline-text-5" id="text-8-4-2-1">
<p>
Translating while loops can be done in multiple ways: <i>(cc is loop condition, cb is loop body)</i>
</p>
<ul class="org-ul">
<li>The one on the right is more efficient</li>
</ul>


<div id="orge44daa8" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_14-50-16_screenshot.png" alt="2024-01-08_14-50-16_screenshot.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Stmt</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">.</span> <span style="color: #dcaeea;">.</span> <span style="color: #dcaeea;">.</span>
          <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">While</span> <span style="color: #ECBE7B;">Expr</span> <span style="color: #ECBE7B;">Stmt</span>

<span style="color: #c678dd;">code</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Stmt</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Code</span>
<span style="color: #c678dd;">code</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">...</span>
<span style="color: #c678dd;">code</span> (<span style="color: #ECBE7B;">While</span> c b) <span style="color: #dcaeea;">=</span> [<span style="color: #ECBE7B;">BRA</span> sb] <span style="color: #dcaeea;">++</span>
                   cb <span style="color: #dcaeea;">++</span>
                   cc <span style="color: #dcaeea;">++</span>
                   [<span style="color: #ECBE7B;">BRT</span> (<span style="color: #dcaeea;">&#8722;</span>(sb <span style="color: #dcaeea;">+</span> sc <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">2</span>))]
    <span style="color: #51afef;">where</span> cc <span style="color: #dcaeea;">=</span> code c
          cb <span style="color: #dcaeea;">=</span> code b
          sc <span style="color: #dcaeea;">=</span> codeSize cc
          sb <span style="color: #dcaeea;">=</span> codeSize cb
</pre>
</div>

<p>
Once again it can be done using an algebra:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">SEAlg</span> s e <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">SEAlg</span>
    { add <span style="color: #dcaeea;">::</span> e <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> e
    , num <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #dcaeea;">-&gt;</span> e
    , ifE <span style="color: #dcaeea;">::</span> e <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> e
    , ifS <span style="color: #dcaeea;">::</span> e <span style="color: #dcaeea;">-&gt;</span> s <span style="color: #dcaeea;">-&gt;</span> s <span style="color: #dcaeea;">-&gt;</span> s
    , asg <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">-&gt;</span> e <span style="color: #dcaeea;">-&gt;</span> s
    , whl <span style="color: #dcaeea;">::</span> e <span style="color: #dcaeea;">-&gt;</span> s <span style="color: #dcaeea;">-&gt;</span> s
    , cal <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">-&gt;</span> [e] <span style="color: #dcaeea;">-&gt;</span> s
    }

<span style="color: #c678dd;">foldSE</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">SEAlg</span> s e <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Statement</span> <span style="color: #dcaeea;">-&gt;</span> s
<span style="color: #c678dd;">foldSE</span> alg {<span style="color: #dcaeea;">.</span> <span style="color: #dcaeea;">.</span>} <span style="color: #dcaeea;">=</span> fs <span style="color: #51afef;">where</span>
    fs (<span style="color: #ECBE7B;">IfS</span> c t f) <span style="color: #dcaeea;">=</span> ifS (fe c) (fs t) (fs f)
    fe (<span style="color: #ECBE7B;">IfE</span> c t f) <span style="color: #dcaeea;">=</span> ifE (fe c) (fe t) (fe f)
    fs (<span style="color: #ECBE7B;">Call</span> v ps) <span style="color: #dcaeea;">=</span> cal v (map fe ps)
    fe (<span style="color: #ECBE7B;">Add</span> x y) <span style="color: #dcaeea;">=</span> add (fe x) (fe y)
    fe (<span style="color: #ECBE7B;">Num</span> n) <span style="color: #dcaeea;">=</span> num n

<span style="color: #c678dd;">code</span> x <span style="color: #dcaeea;">=</span> foldSE codeAlg x empty
    <span style="color: #51afef;">where</span>
    codeAlg <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">SEAlg</span> (<span style="color: #ECBE7B;">Env</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Code</span>) (<span style="color: #ECBE7B;">Env</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Code</span>)
    codeAlg <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">SEAlg</span>
        { asg <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>s d e <span style="color: #dcaeea;">-&gt;</span> d e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">STL</span> (e <span style="color: #dcaeea;">!</span> s)]
        , ifS <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>c t f e <span style="color: #dcaeea;">-&gt;</span>
                <span style="color: #51afef;">let</span> st <span style="color: #dcaeea;">=</span> codeSize (t e)
                sf <span style="color: #dcaeea;">=</span> codeSize (f e)
                <span style="color: #51afef;">in</span> c e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">BRF</span> (st <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">2</span>)] <span style="color: #dcaeea;">++</span>
                t e <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">BRA</span> sf] <span style="color: #dcaeea;">++</span> f e
        , whl <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>c b e <span style="color: #dcaeea;">-&gt;</span>
                <span style="color: #51afef;">let</span> sc <span style="color: #dcaeea;">=</span> codeSize (c e)
                sb <span style="color: #dcaeea;">=</span> codeSize (b e)
                <span style="color: #51afef;">in</span> [<span style="color: #ECBE7B;">BRA</span> sb] <span style="color: #dcaeea;">++</span> b e <span style="color: #dcaeea;">++</span> c e <span style="color: #dcaeea;">++</span>
                [<span style="color: #ECBE7B;">BRT</span> (<span style="color: #dcaeea;">&#8722;</span>(sb <span style="color: #dcaeea;">+</span> sc <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">2</span>))]
        , cal <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>m ps e <span style="color: #dcaeea;">-&gt;</span>
                concatMap (<span style="color: #dcaeea;">$</span>e) ps <span style="color: #dcaeea;">++</span> [<span style="color: #ECBE7B;">BSR</span> m]
        , <span style="color: #dcaeea;">.</span> <span style="color: #dcaeea;">.</span> <span style="color: #dcaeea;">.</span>}
</pre>
</div>
</div>
</li>
<li><a id="orgcadfa0c"></a>Method translation<br />
<div class="outline-text-5" id="text-8-4-2-2">
<p>
A method call:
</p>
<ul class="org-ul">
<li>Put parameters on the stack</li>
<li>Call <a href="#org5f2207e">BSR</a> with method label</li>
</ul>

<p>
A method definition:
</p>
<ul class="org-ul">
<li>Use parameters: from <a href="#orgcc57093">LDS</a> \(-(n+d)\) to \(-(1+d)\)
<ul class="org-ul">
<li>\(n\): number of parameters</li>
<li>\(d\): current offset</li>
</ul></li>
<li>Clean up:
<ul class="org-ul">
<li><a href="#org725e591">STS</a> \(-n\)</li>
<li><a href="#orgffa501a">AJS</a> \(-n\)</li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org0596755"></a>Method translation with local variables<br />
<div class="outline-text-5" id="text-8-4-2-3">
<p>
Method call as before.
</p>

<p>
Method definition (\(n\) parameters, \(k\) local variables)
</p>
<ul class="org-ul">
<li>Create room for local variables: <code>LDR MP</code> to save the mark pointer, <code>LDRR MP SP</code> to reset the mark pointer, <code>AJS +k</code> to adjust the stack pointer. (Also available as a single instruction LINK k.)</li>
<li>Use parameters: from <code>LDL −(n + 1)</code> to <code>LDL −2</code>.</li>
<li>Use local variables: from <code>LDL +1</code> to <code>LDL +k</code>.</li>
<li>Clean up local variables: <code>LDRR SP MP</code> to reset the stack pointer, and <code>STR MP</code> to restore the mark pointer. (Also available as a single instruction <code>UNLINK</code>.)</li>
<li>Clean up: <code>STS −n</code> followed by <code>AJS −(n − 1)</code>.</li>
<li>Return: <code>RET</code></li>
</ul>
</div>
</li>
<li><a id="org5d21fb0"></a>Example method translation with local variables<br />
<div class="outline-text-5" id="text-8-4-2-4">
<div class="org-src-container">
<pre class="src src-C">m(<span style="color: #da8548; font-weight: bold;">7</span>, <span style="color: #da8548; font-weight: bold;">12</span>);
<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">m</span> (<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">x</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">y</span>) {
    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span>;
    a = -x;
    . . .
}
</pre>
</div>

<p>
After the call we push the current mark pointer onto the stack
</p>


<div id="orgfde1da7" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_15-53-33_screenshot.png" alt="2024-01-08_15-53-33_screenshot.png" />
</p>
</div>

<p>
Then we put the contents of the stack pointer into the mark pointer
</p>

<div id="orgb7eb708" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_15-56-06_screenshot.png" alt="2024-01-08_15-56-06_screenshot.png" />
</p>
</div>

<p>
Then we adjust the stack pointer by +2, to make space for a and b
</p>

<div id="org0185743" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_16-01-14_screenshot.png" alt="2024-01-08_16-01-14_screenshot.png" />
</p>
</div>

<p>
Then we load 7, the x variable onto the top of the stack, using <a href="#orga579b7c">LDL</a> -3
</p>

<p>
Then we call <code>NEG</code> which will negate the argument at the top of the stack, 7
</p>

<div id="orgb5b4fc7" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_16-11-19_screenshot.png" alt="2024-01-08_16-11-19_screenshot.png" />
</p>
</div>

<p>
Then we call <a href="#org3e230a7">STL</a> +1 to store -7 in the a variable
</p>


<div id="org09d97dd" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_16-21-16_screenshot.png" alt="2024-01-08_16-21-16_screenshot.png" />
</p>
</div>

<p>
Then we copy the markpointer register to the stack pointer register, returing the stackpointer to the position it was at the beginning of the function call
</p>


<div id="org1a32493" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_16-27-15_screenshot.png" alt="2024-01-08_16-27-15_screenshot.png" />
</p>
</div>

<p>
Then we pop the old position of the mark pointer and put it into the mark pointer.
</p>

<div id="org35ba0de" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_16-30-20_screenshot.png" alt="2024-01-08_16-30-20_screenshot.png" />
</p>
</div>

<p>
Then we call <a href="#org725e591">STS</a> -2, which stores the current top of the stack (the return pointer/adress) two positions up relative to the top of the stack. We do this to remove the arguments of the function from the stack.
</p>

<div id="org34b43d6" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_16-53-16_screenshot.png" alt="2024-01-08_16-53-16_screenshot.png" />
</p>
</div>


<p>
Then we adjust the stack so the return adress is on top
</p>


<div id="org38f73d3" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_16-59-28_screenshot.png" alt="2024-01-08_16-59-28_screenshot.png" />
</p>
</div>

<p>
Then finally, we call the return function
Pops a previously pushed PC from the stack and jumps to it.
</p>


<div id="org8d742a9" class="figure">
<p><img src="Simple_stack_machine/2024-01-08_17-00-16_screenshot.png" alt="2024-01-08_17-00-16_screenshot.png" />
</p>
</div>
</div>
</li>
<li><a id="orgaff9b11"></a>Method translation with return values<br />
<div class="outline-text-5" id="text-8-4-2-5">
<p>
There are two options for methods with return values:
</p>

<p>
Result on stack
</p>
<ul class="org-ul">
<li>Leave the result as the final value on the stack.</li>
<li>Adapt the cleanup code so that this works.</li>
</ul>

<p>
Result in register
</p>
<ul class="org-ul">
<li>Place the result of a method call in a fixed free register (RR for example).</li>
<li>Use the value from there at the call site</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org87df0d5" class="outline-2">
<h2 id="org87df0d5"><span class="section-number-2">9.</span> Validation</h2>
<div class="outline-text-2" id="text-9">
<p>
A compiler will also compile any bugs introduced by a programmer.
</p>

<p>
With machine code the error message usually isn&rsquo;t nice.
</p>
<ul class="org-ul">
<li>Having a clear error message is better</li>
</ul>

<p>
Where do we look for bugs
</p>
<ul class="org-ul">
<li>In the code</li>
<li>Machine code</li>
<li>Runtime?</li>
<li>The programmer?</li>
</ul>

<p>
All technique&rsquo;s ussually has some point of diminishing return.
</p>
<ul class="org-ul">
<li>We should do all!</li>
</ul>

<p>
This lecture we will only look at checking the source code
</p>

<p>
Who check it
</p>
<ul class="org-ul">
<li>programmer</li>
<li>3rd party tester</li>
<li>automated/machine</li>
</ul>

<p>
At code level
</p>
<ul class="org-ul">
<li>Hlint</li>
</ul>

<p>
At AST level
</p>
<ul class="org-ul">
<li>scope</li>
<li>type</li>
<li>termination</li>
<li>borrow</li>
</ul>

<p>
At machine code level
</p>
<ul class="org-ul">
<li>SAST bugrpove</li>
<li>size-limit test</li>
</ul>
</div>
<div id="outline-container-org509feec" class="outline-3">
<h3 id="org509feec"><span class="section-number-3">9.1.</span> Example checks at AST level</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Rest van de lecture was niet boeiend, saai voorbeeld van type checker:
</p>

<p>
Dit is het uiteindelijke resultaat, niet super boeiend.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #5B6268;">{- </span><span style="color: #5B6268;">Language 3: floating-point/boolean expressions</span><span style="color: #5B6268;"> -}</span>

<span style="color: #51afef;">module</span> <span style="color: #ECBE7B;">Demo3</span> <span style="color: #51afef;">where</span>

<span style="color: #51afef;">import</span> <span style="color: #ECBE7B;">Demo1</span> (<span style="color: #ECBE7B;">Valid</span>(<span style="color: #dcaeea;">..</span>))

<span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Exp</span>
  <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Con</span> <span style="color: #ECBE7B;">Float</span>
  <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Add</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
  <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Mul</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
  <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Pow</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
  <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">If</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
  <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Leq</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
  <span style="color: #51afef;">deriving</span> <span style="color: #ECBE7B;">Show</span>

<span style="color: #c678dd;">seven</span> <span style="color: #dcaeea;">=</span>
  <span style="color: #ECBE7B;">If</span> (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">3.0</span> <span style="color: #dcaeea;">`Leq`</span> <span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">4.0</span>)
    (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">7.0</span>)
    (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">9.0</span>)

<span style="color: #c678dd;">eval</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Either</span> <span style="color: #ECBE7B;">Float</span> <span style="color: #ECBE7B;">Bool</span>
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Con</span> k)     <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Left</span> k
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Add</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Left</span> (p <span style="color: #dcaeea;">+</span>  q) <span style="color: #51afef;">where</span> <span style="color: #ECBE7B;">Left</span> p <span style="color: #dcaeea;">=</span> eval e1; <span style="color: #ECBE7B;">Left</span> q <span style="color: #dcaeea;">=</span> eval e2
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Mul</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Left</span> (p <span style="color: #dcaeea;">*</span>  q) <span style="color: #51afef;">where</span> <span style="color: #ECBE7B;">Left</span> p <span style="color: #dcaeea;">=</span> eval e1; <span style="color: #ECBE7B;">Left</span> q <span style="color: #dcaeea;">=</span> eval e2
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Pow</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Left</span> (p <span style="color: #dcaeea;">**</span> q) <span style="color: #51afef;">where</span> <span style="color: #ECBE7B;">Left</span> p <span style="color: #dcaeea;">=</span> eval e1; <span style="color: #ECBE7B;">Left</span> q <span style="color: #dcaeea;">=</span> eval e2
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">If</span> h t e) <span style="color: #dcaeea;">=</span> <span style="color: #51afef;">if</span> h' <span style="color: #51afef;">then</span> eval t <span style="color: #51afef;">else</span> eval t <span style="color: #51afef;">where</span>
  <span style="color: #ECBE7B;">Right</span> h' <span style="color: #dcaeea;">=</span> eval h
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Leq</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Right</span> (p <span style="color: #dcaeea;">&lt;=</span> q) <span style="color: #51afef;">where</span> <span style="color: #ECBE7B;">Left</span> p <span style="color: #dcaeea;">=</span> eval e1; <span style="color: #ECBE7B;">Left</span> q <span style="color: #dcaeea;">=</span> eval e2

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#9989; eval seven</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; eval is ugly</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128373;</span><span style="color: #5B6268;"> -}</span>

<span style="color: #c678dd;">nseven</span> <span style="color: #dcaeea;">=</span>
  <span style="color: #ECBE7B;">If</span> (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">3.0</span>)
    (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">7.0</span>)
    (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">9.0</span>)

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&gt; eval nseven</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; crashes on the user's computer!</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128161; write type-checker</span><span style="color: #5B6268;"> -}</span>

<span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Type</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Float</span> <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Bool</span>
  <span style="color: #51afef;">deriving</span> (<span style="color: #ECBE7B;">Show</span>, <span style="color: #ECBE7B;">Eq</span>)

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check :: Type -&gt; Exp -&gt; Bool</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Con _) = True</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Add e1 e2) = check Float e1 &amp;&amp; check Float e2</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Mul e1 e2) = check Float e1 &amp;&amp; check Float e2</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Pow e1 e2) = check Float e1 &amp;&amp; check Float e2</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check ty (If h t e) = check Bool h &amp;&amp; check ty t &amp;&amp; check ty e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check _ _ = False</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval :: Type -&gt; Exp -&gt; Maybe (Either Float Bool)</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval t e =</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">if check t e</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">then Just $ eval e</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">else Nothing</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&gt; safeEval Float nseven</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; safeEval should not need a Type param</span><span style="color: #5B6268;"> -}</span>
<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; 'Nothing' is not a nice error message</span><span style="color: #5B6268;"> -}</span>
<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; eval is ugly</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128161; get rid of the Type param by inferring type</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer :: Exp -&gt; Maybe Type</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Con _)   = if check Float e then Just Float else Nothing</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Add _ _) = if check Float e then Just Float else Nothing</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Mul _ _) = if check Float e then Just Float else Nothing</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Pow _ _) = if check Float e then Just Float else Nothing</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Leq _ _) = if check Bool e  then Just Bool  else Nothing</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer (If h t e) = do</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">t_ty &lt;- infer t</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">e_ty &lt;- infer e</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">if t_ty == e_ty &amp;&amp; check Bool h</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">then Just t_ty</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">else Nothing</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">note the re-use of check (to avoid duplication)</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval :: Exp -&gt; Maybe (Either Float Bool)</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval e = infer e &gt;&gt; Just (eval e)</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&gt; safeEval nseven</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; infer, check ugly</span><span style="color: #5B6268;"> -}</span>
<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; 'Nothing' is not a nice error message</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128161; use Maybe () instead of Bool to unlock &lt;*&gt; etc.</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check :: Type -&gt; Exp -&gt; Maybe ()</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Con _)     = Just ()</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Add e1 e2) = () &lt;$ check Float e1 &lt;* check Float e2</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Mul e1 e2) = () &lt;$ check Float e1 &lt;* check Float e2</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Pow e1 e2) = () &lt;$ check Float e1 &lt;* check Float e2</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check ty (If h t e)     = () &lt;$ check Bool h &lt;* check ty t &lt;* check ty e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check _ _ = Nothing</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer :: Exp -&gt; Maybe Type</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Con _)   = Float &lt;$ check Float e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Add _ _) = Float &lt;$ check Float e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Mul _ _) = Float &lt;$ check Float e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Pow _ _) = Float &lt;$ check Float e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Leq _ _) = Bool  &lt;$ check Bool e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer (If h t e) = do</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">check Bool h</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">t_ty &lt;- infer t</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">t_ty &lt;$ check t_ty e</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval :: Exp -&gt; Maybe (Either Float Bool)</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval e = infer e &gt;&gt; Just (eval e)</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">Unchanged: safeEval nseven</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; 'Nothing' is not a nice error message</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128161; replace Maybe with Either</span><span style="color: #5B6268;"> -}</span>

<span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">CheckingErr</span> <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Expected</span> <span style="color: #ECBE7B;">Type</span> <span style="color: #5B6268;">{- </span><span style="color: #5B6268;">in</span><span style="color: #5B6268;"> -}</span> <span style="color: #ECBE7B;">Exp</span>
  <span style="color: #51afef;">deriving</span> <span style="color: #ECBE7B;">Show</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check :: Type -&gt; Exp -&gt; Either CheckingErr ()</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Con _)     = Right ()</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Add e1 e2) = () &lt;$ check Float e1 &lt;* check Float e2          -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Mul e1 e2) = () &lt;$ check Float e1 &lt;* check Float e2          -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check Float (Pow e1 e2) = () &lt;$ check Float e1 &lt;* check Float e2          -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check ty (If h t e)     = () &lt;$ check Bool h &lt;* check ty t &lt;* check ty e  -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">check expected_ty e     = Left $ Expected expected_ty e</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer :: Exp -&gt; Either CheckingErr Type</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Con _)   = Float &lt;$ check Float e</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Add _ _) = Float &lt;$ check Float e  -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Mul _ _) = Float &lt;$ check Float e  -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Pow _ _) = Float &lt;$ check Float e  -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer e@(Leq _ _) = Bool  &lt;$ check Bool  e  -- unchanged</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">infer (If h t e) = do                       -- unchanged</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">check Bool h                              -- unchanged</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">t_ty &lt;- infer t                           -- unchanged</span>
<span style="color: #5B6268;">--   </span><span style="color: #5B6268;">t_ty &lt;$ check t_ty e                      -- unchanged</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval :: Exp -&gt; Either CheckingErr (Either Float Bool)</span>
<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">safeEval e = infer e &gt;&gt; Right (eval e)</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">{- &#9989; safeEval nseven -}</span>

<span style="color: #c678dd;">neight</span> <span style="color: #dcaeea;">=</span>
  <span style="color: #ECBE7B;">If</span> (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">3.0</span>)
    (<span style="color: #ECBE7B;">If</span> (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">0.0</span>) (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">0.0</span>) (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">0.0</span>))
    (<span style="color: #ECBE7B;">Con</span> <span style="color: #da8548; font-weight: bold;">8.0</span>)

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&gt; safeEval neight</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; only one error reported!</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128161; bring back Valid</span><span style="color: #5B6268;"> -}</span>

<span style="color: #c678dd;">check</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Type</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Valid</span> [<span style="color: #ECBE7B;">CheckingErr</span>] <span style="color: #ECBE7B;">()</span>
<span style="color: #c678dd;">check</span> <span style="color: #ECBE7B;">Float</span> (<span style="color: #ECBE7B;">Con</span> <span style="color: #51afef;">_</span>)     <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">OK</span> <span style="color: #ECBE7B;">()</span>
<span style="color: #c678dd;">check</span> <span style="color: #ECBE7B;">Float</span> (<span style="color: #ECBE7B;">Add</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">()</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Float</span> e1 <span style="color: #dcaeea;">&lt;*</span> check <span style="color: #ECBE7B;">Float</span> e2          <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">check</span> <span style="color: #ECBE7B;">Float</span> (<span style="color: #ECBE7B;">Mul</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">()</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Float</span> e1 <span style="color: #dcaeea;">&lt;*</span> check <span style="color: #ECBE7B;">Float</span> e2          <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">check</span> <span style="color: #ECBE7B;">Float</span> (<span style="color: #ECBE7B;">Pow</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">()</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Float</span> e1 <span style="color: #dcaeea;">&lt;*</span> check <span style="color: #ECBE7B;">Float</span> e2          <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">check</span> ty (<span style="color: #ECBE7B;">If</span> h t e)     <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">()</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Bool</span> h <span style="color: #dcaeea;">&lt;*</span> check ty t <span style="color: #dcaeea;">&lt;*</span> check ty e  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">check</span> expected_ty e     <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Err</span> [<span style="color: #ECBE7B;">Expected</span> expected_ty e]

<span style="color: #c678dd;">infer</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Valid</span> [<span style="color: #ECBE7B;">CheckingErr</span>] <span style="color: #ECBE7B;">Type</span>
<span style="color: #c678dd;">infer</span> e<span style="color: #dcaeea;">@</span>(<span style="color: #ECBE7B;">Con</span> <span style="color: #51afef;">_</span>)   <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Float</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Float</span> e  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">infer</span> e<span style="color: #dcaeea;">@</span>(<span style="color: #ECBE7B;">Add</span> <span style="color: #51afef;">_</span> <span style="color: #51afef;">_</span>) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Float</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Float</span> e  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">infer</span> e<span style="color: #dcaeea;">@</span>(<span style="color: #ECBE7B;">Mul</span> <span style="color: #51afef;">_</span> <span style="color: #51afef;">_</span>) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Float</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Float</span> e  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">infer</span> e<span style="color: #dcaeea;">@</span>(<span style="color: #ECBE7B;">Pow</span> <span style="color: #51afef;">_</span> <span style="color: #51afef;">_</span>) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Float</span> <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Float</span> e  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">infer</span> e<span style="color: #dcaeea;">@</span>(<span style="color: #ECBE7B;">Leq</span> <span style="color: #51afef;">_</span> <span style="color: #51afef;">_</span>) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Bool</span>  <span style="color: #dcaeea;">&lt;$</span> check <span style="color: #ECBE7B;">Bool</span>  e  <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
<span style="color: #c678dd;">infer</span> (<span style="color: #ECBE7B;">If</span> h t e) <span style="color: #dcaeea;">=</span> <span style="color: #51afef;">do</span>                       <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
  check <span style="color: #ECBE7B;">Bool</span> h                              <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
  t_ty <span style="color: #dcaeea;">&lt;-</span> infer t                           <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>
  t_ty <span style="color: #dcaeea;">&lt;$</span> check t_ty e                      <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">unchanged</span>

<span style="color: #c678dd;">safeEval</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Valid</span> [<span style="color: #ECBE7B;">CheckingErr</span>] (<span style="color: #ECBE7B;">Either</span> <span style="color: #ECBE7B;">Float</span> <span style="color: #ECBE7B;">Bool</span>)
<span style="color: #c678dd;">safeEval</span> e <span style="color: #dcaeea;">=</span> infer e <span style="color: #dcaeea;">&gt;&gt;</span> <span style="color: #ECBE7B;">OK</span> (eval e)

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#9989; safeEval neight</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#128169; eval is still ugly</span><span style="color: #5B6268;"> -}</span>

<span style="color: #5B6268;">{- </span><span style="color: #5B6268;">&#127947;&#127947; implement...</span>
<span style="color: #5B6268;">  * A type Exp_Float allowing *only* Float-typed Exps</span>
<span style="color: #5B6268;">  * validate  :: Exp -&gt; Valid [CheckingErr] Exp_Float</span>
<span style="color: #5B6268;">  * evalFloat :: Exp_Float -&gt; Float</span>
<span style="color: #5B6268;">  * safeEval in terms of `validate` and `evalFloat`</span>

<span style="color: #5B6268;">Hint: you will also need to implement</span>
<span style="color: #5B6268;">  corresponding defintions for Bool-typed Exp s</span>
<span style="color: #5B6268;">  (or use a GADT)</span>
<span style="color: #5B6268;">-}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7167768" class="outline-2">
<h2 id="org7167768"><span class="section-number-2">10.</span> Pumping Lemmas, proving (non)regular languages</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-orge01b8b8" class="outline-3">
<h3 id="orge01b8b8"><span class="section-number-3">10.1.</span> General strategy for proving a language (non) regular</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Regular language: a language that can be expressed using a regular expression, sometimes defined as a language recognised by a finite automaton.
</p>

<p>
Generally, proving that a language does not belong to a certain class is much more difficult than proving that it does.
</p>

<p>
In the case of regular languages,
</p>

<ul class="org-ul">
<li>to show that a language is regular, we have to give one regular grammar (or regular expression, or DFA, or NFA) that describes the language;</li>
<li>to show that a language is not regular, we have to prove that no regular grammar (or regular expression, or DFA, or NFA) is possible that describes the language</li>
</ul>

<p>
The strategy is as follows:
</p>
<ol class="org-ol">
<li>we expose a limitation in the formalism (in this case, in the concept of finite state automata);</li>
<li>from this limitation, we derive a property that all languages in the class (in this case, regular languages) must have;</li>
<li>therefore, if a language does not have that property, it cannot be in the class.</li>
</ol>
</div>
</div>
<div id="outline-container-org6a4e217" class="outline-3">
<h3 id="org6a4e217"><span class="section-number-3">10.2.</span> Proving a language non-regular</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Assume we have a <a href="#orgcac8e86">deterministic finite state automaton</a>
</p>
</div>
<div id="outline-container-org28db763" class="outline-4">
<h4 id="org28db763"><span class="section-number-4">10.2.1.</span> Strategy step 1: limitation in the formalism</h4>
<div class="outline-text-4" id="text-10-2-1">
<p>
we expose a limitation in the formalism (in this case, in the concept of finite state automata)
</p>

<p>
Any finite state automaton has a finite number of states.
</p>

<p>
Assume we have one with n states.
</p>

<p>
How many different states do we visit while reading a string that is accepted and has length n?
</p>

<p>
n + 1 or less, and if less, we traverse a loop. But there are only n states, so we cannot traverse n + 1 different states. Therefore, we must traverse a loop.
</p>

<p>
We have done the first step of the strategy. We have found a limitation in the formalism. Now we have to derive a property for all regular languages from that.
</p>
</div>
</div>
<div id="outline-container-org851f637" class="outline-4">
<h4 id="org851f637"><span class="section-number-4">10.2.2.</span> Step 2: property of language class</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
From previous limitation, we derive a property that all languages in the class (in this case, regular languages) must have.
</p>

<p>
If we have a word that is accepted and traverses the loop once, then the words that follow the same path and traverse the loop any other number of times are also accepted
</p>


<div id="org8285b20" class="figure">
<p><img src="Pumping_Lemmas,_proving_(non)regular_languages/2024-01-20_15-57-18_screenshot.png" alt="2024-01-20_15-57-18_screenshot.png" />
</p>
</div>

<p>
This is an excerpt of the automaton. There may be other nodes and edges.
</p>
<ul class="org-ul">
<li>Both u and w may be empty (i.e. A and S or A and E may be the same state), but v is not empty – there is a proper loop.</li>
<li>All words of the form \(uv^iw\) for \(i\in \mathbb{N}\) are accepted.</li>
</ul>

<p>
A loop has to occur in every <b>subword</b> of at least length n:
</p>


<div id="orgb31600e" class="figure">
<p><img src="Pumping_Lemmas,_proving_(non)regular_languages/2024-01-20_16-17-55_screenshot.png" alt="2024-01-20_16-17-55_screenshot.png" />
</p>
</div>

<p>
Assume we have an accepted word xyz where subword y is of at least length n
</p>

<p>
A loop has to occur in every subword of at least length n:
</p>


<div id="org2e01631" class="figure">
<p><img src="Pumping_Lemmas,_proving_(non)regular_languages/2024-01-20_16-18-55_screenshot.png" alt="2024-01-20_16-18-55_screenshot.png" />
</p>
</div>

<ul class="org-ul">
<li>Assume we have an accepted word xyz where subword y is of at least length n.</li>
<li>Then y has to be of form uvw where v is not empty and corresponds to a loop.</li>
<li>All words of the form \(xuv^iwz\) for \(i\in\mathbb{N}\) are accepted</li>
</ul>

<p>
<b>Pumping lemma for regular languages:</b>
</p>
<ul class="org-ul">
<li>For every regular language L, there exists an \(n\in \mathbb{N}\)
<ul class="org-ul">
<li>(corresponding to the number of states in the automaton)</li>
</ul></li>
<li>such that for every word \(xyz\) in L with \(|y| \ge n\),
<ul class="org-ul">
<li>(this holds for every long substring of every word in L)</li>
</ul></li>
<li>we can split y into three parts, \(y = uvw\), with \(|v| > 0\),
<ul class="org-ul">
<li>(v is a loop)</li>
</ul></li>
<li>such that for every \(i\in\mathbb{N}\) , we have \(xuv^iwz \in L\)</li>
</ul>
</div>
</div>
<div id="outline-container-org6b66cf7" class="outline-4">
<h4 id="org6b66cf7"><span class="section-number-4">10.2.3.</span> Step 3: pumping lemma</h4>
<div class="outline-text-4" id="text-10-2-3">
<p>
The we proceed with the final step of the strategy. In order to show that a language is not regular, we show that it does not have the pumping lemma property as follows:
</p>
<ul class="org-ul">
<li>We assume that the language is regular.</li>
<li>We use the pumping lemma to derive a word that must be in the language, but is not:
<ul class="org-ul">
<li>find a word \(xyz\) in L with \(|y| \ge n\),</li>
<li>from the pumping lemma there must be a loop in y,</li>
<li>but repeating this loop, or omitting it, takes us outside of the language.</li>
</ul></li>
<li>The contradiction means that the language cannot be regular.</li>
</ul>

<p>
Using the pumping lemma - strategy
</p>
<ul class="org-ul">
<li>For every natural number n,
<ul class="org-ul">
<li>because you don’t know what the value of n is</li>
</ul></li>
<li>find a word xyz in L with \(|y| \ge n\) (you choose the word),</li>
<li>such that for every splitting \(y = uvw\) with \(|v| > 0\),
<ul class="org-ul">
<li>because you don’t know where the loop may be</li>
</ul></li>
<li>there exists a number i (you figure out the number),</li>
<li>such that \(xuv^iwz\notin L\) (you have to prove it).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4dcadac" class="outline-3">
<h3 id="org4dcadac"><span class="section-number-3">10.3.</span> <span class="todo TODO">TODO</span> Proving context-free grammar</h3>
<div class="outline-text-3" id="text-10-3">
<p>
A context-free grammar consists of a sequence of productions:
</p>
<ul class="org-ul">
<li>the left hand side is always a nonterminal,</li>
<li>the right hand side is any sequence of terminals and nonterminals.</li>
</ul>

<p>
One nonterminal of the grammar is the start symbol.
</p>

<p>
<b>Context-sensitive grammars</b> drop the restriction on the left hand side:
</p>
<ul class="org-ul">
<li>\(a N b \rightarrow x\)</li>
</ul>

<p>
Context-sensitive grammars are as powerful as any other computing formalism:
</p>
<ul class="org-ul">
<li>Turing machines</li>
<li>λ-calculus</li>
</ul>

<p>
If we want to prove that a certain language is not context-free, we can apply the same strategy as for regular languages:
</p>
<ul class="org-ul">
<li>we expose a limitation in the formalism (in this case, in the concept of context-free grammars);</li>
<li>from this limitation, we derive a property that all languages in the class (in this case, context-free languages) must have;</li>
<li>therefore, if a language does not have that property, it cannot be in the class.</li>
</ul>
</div>
<div id="outline-container-org6f73ef9" class="outline-4">
<h4 id="org6f73ef9"><span class="section-number-4">10.3.1.</span> Step 1: limitation in the formalism</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
This time, we analyze parse trees rather than finite state
automata.
</p>
<ul class="org-ul">
<li>We can produce parse trees of arbitrary depth if we find words in the language that are long enough, because the number of children per node is bounded by the maximum length of a right hand side of a production.</li>
<li>Once a path from a leaf to the root has more than n internal nodes, where n is the number of nonterminals in the grammar, one nonterminal has to occur twice on such a path
<ul class="org-ul">
<li>consequently a subtree can be inserted as often as desired</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgba62083" class="outline-4">
<h4 id="orgba62083"><span class="section-number-4">10.3.2.</span> Step 2: property of language class</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
If the word is long enough, we have a derivation of the form
</p>
<ul class="org-ul">
<li>For a word to be a certain length, some non-terminals must occur twice</li>
</ul>

<p>
\[S \Rightarrow^* uAy \Rightarrow^* uvAxy \Rightarrow^* uvwxy\]
</p>

<p>
where \(|vx| > 0\).
</p>

<p>
Because the grammar is context-free, this implies that
</p>

<p>
\[A\Rightarrow^*vAx\]
\[A\Rightarrow^*w\]
</p>

<p>
We can thus derive
</p>

<p>
\[S\Rightarrow ^* uAy \Rightarrow ^* uv^iwx^iy\]
</p>

<p>
for any \(i\in\mathbb N\)
</p>
</div>
</div>
<div id="outline-container-org6ecad38" class="outline-4">
<h4 id="org6ecad38"><span class="section-number-4">10.3.3.</span> Step 3: pumping lemma</h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
Pumping lemma for context-free languages
</p>

<p>
For every context-free language L,
</p>
<ul class="org-ul">
<li>there exists a number \(n\in\mathbb N\) such that</li>
<li>for every word \(z\in L\) with \(|z| \ge n\)</li>
<li>we can split z into five parts, \(z = uvwxy\), with \(|vx| > 0\) and \(|vwx| \ge n\), such that</li>
<li>for every \(i \in N\), we have \(uv^iwx^iy \in L\).</li>
</ul>

<p>
The n lets us limit the size of the part that gets pumped, similar to how the pumping lemma for regular languages lets us choose the subword that contains te loop.
</p>

<p>
<b>Using the pumping lemma:</b>
</p>
<ul class="org-ul">
<li>For every number n,</li>
<li>find a word z in L with |z| ⩾ n (you choose the word),</li>
<li>such that for every splitting z = uvwxy with |vx| &gt; 0 and |vwx| ⩽ n,</li>
<li>there exists a number i (you choose the number),</li>
<li>such that \(uv^iwx^iy \notin L\) (you have to prove it)</li>
</ul>

<p>
Example:
</p>
<ul class="org-ul">
<li>The language \(L = \{a^mb^mc^m | m \in \mathbb N\}\) is not context-free.</li>
<li>Let n be any number.</li>
<li>We then consider the word \(z = a^nb^nc^n\).</li>
<li>From the pumping lemma, we learn that we can pump z, and that the part that gets pumped is smaller than n.</li>
<li>The part being pumped can thus not contain a’s, b’s and c’s at the same time, and is not empty either. In all these cases, we pump out of the language (for any \(i \ne 1\))</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge3e1585" class="outline-3">
<h3 id="orge3e1585"><span class="section-number-3">10.4.</span> Normal forms</h3>
<div class="outline-text-3" id="text-10-4">
<p>
Context-free grammars can be wildly complex, in general.
</p>

<p>
But all of them can be brought into more normalised forms.
</p>

<ul class="org-ul">
<li>We call them normal forms.</li>
</ul>

<p>
We get to them by applying grammar transformations <a href="#orgb228a48">(see lecture 4)</a>.
</p>
</div>
<div id="outline-container-org171b0be" class="outline-4">
<h4 id="org171b0be"><span class="section-number-4">10.4.1.</span> Chomksy Normal Form</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
A context-free grammar is in Chomsky Normal Form if each production rule has one of these forms:
</p>
<ul class="org-ul">
<li>A → B C</li>
<li>A → x</li>
<li>S → ε</li>
</ul>

<p>
where A, B, and C are nonterminals, x is a terminal, and S is the start symbol of the grammar. Also, B and C cannot be S
</p>
<ul class="org-ul">
<li>No rule produces ε except (possibly) from the start.</li>
<li>No chain rules of the form A → B.</li>
<li>Parse trees are always binary.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd717739" class="outline-4">
<h4 id="orgd717739"><span class="section-number-4">10.4.2.</span> Greibach Normal Form</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
A context-free grammar is in Greibach Normal Form if each production rule has one of these forms:
</p>
<ul class="org-ul">
<li>\(A \rightarrow xA_1A_2 . . . A_n\)</li>
<li>\(S \rightarrow \epsilon\)</li>
</ul>
<p>
where \(A, A_1, . . . , A_n\) are nonterminals \((n \ge 0)\), \(x\) is a terminal, and S is the start symbol of the grammar and does not occur in any right hand side.
</p>
<ul class="org-ul">
<li>At most one rule produces ε, and only from the start.</li>
<li>No left recursion.</li>
<li>A derivation of a word of length n has exactly n rule applications (except ε).</li>
<li>Generalizes GNF for regular grammars (where n ⩽ 1)</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org286a50f" class="outline-2">
<h2 id="org286a50f"><span class="section-number-2">11.</span> Nanopass Compilation</h2>
<div class="outline-text-2" id="text-11">
<p>
A nanopass compiler is a compiler that focusses on creating small passes and many intermediate representations. This makes them easier to understand and maintain.
</p>

<p>
This becomes very important for compilers, because compilers are very complex: language options, different compilation targets, support lsp features etc.
</p>
</div>
<div id="outline-container-org6543bbb" class="outline-3">
<h3 id="org6543bbb"><span class="section-number-3">11.1.</span> Nanopass passes</h3>
<div class="outline-text-3" id="text-11-1">
<p>
The following is just a bunch of passes a nanopass compiler might do
</p>
</div>
<div id="outline-container-org6a07812" class="outline-4">
<h4 id="org6a07812"><span class="section-number-4">11.1.1.</span> Parse</h4>
<div class="outline-text-4" id="text-11-1-1">

<div id="org791f17c" class="figure">
<p><img src="Nanopass_Compilation/2024-01-30_16-22-33_screenshot.png" alt="2024-01-30_16-22-33_screenshot.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org3a1cef6" class="outline-4">
<h4 id="org3a1cef6"><span class="section-number-4">11.1.2.</span> Type-Check</h4>
<div class="outline-text-4" id="text-11-1-2">
<p>
Checks the types
<img src="Nanopass_Compilation/2024-01-30_16-23-29_screenshot.png" alt="2024-01-30_16-23-29_screenshot.png" />
</p>
</div>
</div>
<div id="outline-container-org972bf2c" class="outline-4">
<h4 id="org972bf2c"><span class="section-number-4">11.1.3.</span> for → while</h4>
<div class="outline-text-4" id="text-11-1-3">
<p>
Translates for loops to while loops
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; l.length; i++<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    <span style="color: #c678dd;">do_stuff</span><span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Translated to:
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #51afef;">while</span><span style="color: #51afef;">(</span>i &lt; l.length<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    <span style="color: #c678dd;">do_stuff</span><span style="color: #c678dd;">()</span>;
    i++;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Can be implemented as such:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">for2while</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">AstF</span> <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">AstW</span>
<span style="color: #c678dd;">for2while</span> (<span style="color: #ECBE7B;">For</span> (i,c,n) b) <span style="color: #dcaeea;">=</span> i <span style="color: #dcaeea;">`Seq`</span> <span style="color: #ECBE7B;">While</span> c (b <span style="color: #dcaeea;">`Seq`</span> n)
<span style="color: #c678dd;">for2while</span> (<span style="color: #ECBE7B;">Call</span> f) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Call</span> f
<span style="color: #c678dd;">for2while</span> (<span style="color: #ECBE7B;">Var</span> i) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Var</span> i
<span style="color: #c678dd;">for2while</span> (<span style="color: #ECBE7B;">Add</span> e1 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Add</span> e1 e2
<span style="color: #c678dd;">for2while</span> (<span style="color: #ECBE7B;">Seq</span> e2 e2) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Seq</span> e2 e2
<span style="color: #c678dd;">for2while</span> <span style="color: #51afef;">_</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">...</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org24f9084" class="outline-4">
<h4 id="org24f9084"><span class="section-number-4">11.1.4.</span> λ → class</h4>
<div class="outline-text-4" id="text-11-1-4">
<p>
Convert any lambda function to a class
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">int</span><span style="color: #51afef;">[]</span> <span style="color: #c678dd;">squares</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span><span style="color: #c678dd;">[]</span> <span style="color: #dcaeea;">l</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">Logger</span> <span style="color: #dcaeea;">q</span> = <span style="color: #c678dd;">get_logger</span><span style="color: #c678dd;">()</span>;
    <span style="color: #51afef;">return</span> <span style="color: #c678dd;">sum</span><span style="color: #c678dd;">(</span> <span style="color: #c678dd;">map</span><span style="color: #98be65;">(</span><span style="color: #a9a1e1;">(</span>x =&gt; x*x<span style="color: #a9a1e1;">)</span>, l<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Get translated to:
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">int</span><span style="color: #51afef;">[]</span> <span style="color: #c678dd;">squares</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span><span style="color: #c678dd;">[]</span> <span style="color: #dcaeea;">l</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">Logger</span> <span style="color: #dcaeea;">q</span> = <span style="color: #c678dd;">get_logger</span><span style="color: #c678dd;">()</span>;
    <span style="color: #51afef;">return</span> <span style="color: #c678dd;">sum</span><span style="color: #c678dd;">(</span> <span style="color: #c678dd;">map</span><span style="color: #98be65;">(</span><span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Lam43</span><span style="color: #a9a1e1;">()</span> , l<span style="color: #98be65;">)</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Lam43</span> : <span style="color: #ECBE7B;">Runnable</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">object</span> <span style="color: #c678dd;">run</span> <span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">object</span> <span style="color: #dcaeea;">x</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
        <span style="color: #51afef;">return</span> x*x;
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5650775" class="outline-4">
<h4 id="org5650775"><span class="section-number-4">11.1.5.</span> class → struct</h4>
<div class="outline-text-4" id="text-11-1-5">
<p>
Convert all classes to references to structs
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Player</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">uint</span> <span style="color: #dcaeea;">coins</span>;
    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">hiscore</span>;

    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">again</span><span style="color: #c678dd;">(){</span>
        <span style="color: #51afef;">if</span><span style="color: #98be65;">(</span>coins-- &gt; <span style="color: #da8548; font-weight: bold;">0</span><span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
            <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">score</span> = <span style="color: #c678dd;">play</span><span style="color: #a9a1e1;">()</span>;
            hiscore = <span style="color: #c678dd;">max</span><span style="color: #a9a1e1;">(</span><span style="color: #ECBE7B;">score</span>, <span style="color: #ECBE7B;">hiscore</span><span style="color: #a9a1e1;">)</span>;
            <span style="color: #98be65;">}</span>
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Get translated to:
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Player</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">uint</span> <span style="color: #dcaeea;">coins</span>;
    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">hiscore</span>;
<span style="color: #51afef;">}</span>

<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">again</span><span style="color: #51afef;">(</span>Player* self<span style="color: #51afef;">){</span>
    <span style="color: #51afef;">if</span><span style="color: #c678dd;">(</span>self-&gt;coins-- &gt; <span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">){</span>
        <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">score</span> = <span style="color: #c678dd;">play</span><span style="color: #98be65;">()</span>;
        self-&gt;hiscore =
        <span style="color: #c678dd;">max</span><span style="color: #98be65;">(</span>score, self-&gt;hiscore<span style="color: #98be65;">)</span>;
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org68546ec" class="outline-4">
<h4 id="org68546ec"><span class="section-number-4">11.1.6.</span> Insert Reference-Counting code</h4>
<div class="outline-text-4" id="text-11-1-6">
<p>
Keep track of the amount of things still using a certain object, garbage collect object if it isn&rsquo;t used anymore.
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">test</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">int</span><span style="color: #c678dd;">[]</span> <span style="color: #dcaeea;">xs</span> = <span style="color: #c678dd;">list</span><span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">1000000</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">int</span><span style="color: #c678dd;">[]</span> <span style="color: #dcaeea;">ys</span> = <span style="color: #c678dd;">map</span><span style="color: #c678dd;">(</span>xs, inc<span style="color: #c678dd;">)</span>;
    <span style="color: #c678dd;">print</span><span style="color: #c678dd;">(</span>ys<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Get translated to:
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">test</span><span style="color: #51afef;">()</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">int</span><span style="color: #c678dd;">[]</span> <span style="color: #dcaeea;">xs</span> = <span style="color: #c678dd;">list</span><span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">1000000</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">int</span><span style="color: #c678dd;">[]</span> <span style="color: #dcaeea;">ys</span> = <span style="color: #c678dd;">map</span><span style="color: #c678dd;">(</span>xs, inc<span style="color: #c678dd;">)</span>;
    <span style="color: #c678dd;">_drop</span><span style="color: #c678dd;">(</span>xs<span style="color: #c678dd;">)</span>;
    <span style="color: #c678dd;">print</span><span style="color: #c678dd;">(</span>ys<span style="color: #c678dd;">)</span>;
    <span style="color: #c678dd;">_drop</span><span style="color: #c678dd;">(</span>ys<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5e0f78a" class="outline-4">
<h4 id="org5e0f78a"><span class="section-number-4">11.1.7.</span> Constant folding</h4>
<div class="outline-text-4" id="text-11-1-7">
<p>
Inline constants. Not essential, is and optimisation
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">float</span> <span style="color: #c678dd;">circle_area</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">r</span><span style="color: #51afef;">){</span>
    <span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">pi</span> = <span style="color: #c678dd;">calc_pi</span><span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">5</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">return</span> pi * r * r;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Get translated to:
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">float</span> <span style="color: #c678dd;">circle_area</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">float</span> <span style="color: #dcaeea;">r</span><span style="color: #51afef;">){</span>
    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">3.13159</span> * r * r;
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc778cf2" class="outline-4">
<h4 id="orgc778cf2"><span class="section-number-4">11.1.8.</span> if,while, &#x2026; → goto</h4>
<div class="outline-text-4" id="text-11-1-8">
<p>
Translate conditionals and jumps into goto&rsquo;s:
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span>l.length &gt; <span style="color: #da8548; font-weight: bold;">7</span><span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    u = <span style="color: #c678dd;">insertion_sort</span><span style="color: #c678dd;">(</span>l<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
<span style="color: #51afef;">else</span>
<span style="color: #51afef;">{</span>
    u = <span style="color: #c678dd;">quick_sort</span><span style="color: #c678dd;">(</span>l<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Get translated to:
</p>
<div class="org-src-container">
<pre class="src src-csharp">.L0:
l.length &gt; <span style="color: #da8548; font-weight: bold;">7</span>
branch .L1 .L2
.L1:
u = <span style="color: #c678dd;">insertion_sort</span><span style="color: #51afef;">(</span>l<span style="color: #51afef;">)</span>
<span style="color: #51afef;">goto</span> .L3
.L2:
u = <span style="color: #c678dd;">quick_sort</span><span style="color: #51afef;">(</span>l<span style="color: #51afef;">)</span>
<span style="color: #51afef;">goto</span> .L3
.L3:
</pre>
</div>
</div>
</div>
<div id="outline-container-orge31e81e" class="outline-4">
<h4 id="orge31e81e"><span class="section-number-4">11.1.9.</span> SSM instructions → x86<sub>64</sub> instructions</h4>
<div class="outline-text-4" id="text-11-1-9">
<p>
Translate the SSM to actual x86 instructions
</p>
<div class="org-src-container">
<pre class="src src-ssm">global.get __stack_pointer
local.set 3
i32.const 32
local.set 4
local.get 3
local.get 4
i32.sub
local.set 5
local.get 5
global.set __stack_pointer
i32.const 1
local.set 6
local.get 2
local.set 7
local.get 6
local.set 8
local.get 7
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ssm">sub rsp, 88
mov qword ptr [rsp + 8], rdx
mov qword ptr [rsp + 16], rs
mov qword ptr [rsp + 24], rd
mov qword ptr [rsp + 32], rd
cmp rdx, 1
ja .LBB0_2
mov rax, qword ptr [rsp + 32
mov rcx, qword ptr [rsp + 24
mov rdx, qword ptr [rsp + 8]
mov rsi, qword ptr [rsp + 16
mov qword ptr [rcx], rsi
mov qword ptr [rcx + 8], rdx
mov rsi, qword ptr [rip + .L
mov rdx, qword ptr [rip + .L
mov qword ptr [rcx + 32], rs
mov qword ptr [rcx + 40],
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfba7281" class="outline-3">
<h3 id="orgfba7281"><span class="section-number-3">11.2.</span> Nano parse abstract syntax tree?</h3>
<div class="outline-text-3" id="text-11-2">
<p>
What kind of abstract syntax tree should we use for each nanopass?
</p>

<p>
There are quite a lot of options:
</p>
</div>
<div id="outline-container-orgc1cba6b" class="outline-4">
<h4 id="orgc1cba6b"><span class="section-number-4">11.2.1.</span> Many ASTs</h4>
<div class="outline-text-4" id="text-11-2-1">
<p>
Use a new AST for each different representation
</p>

<p>
This works but has disadvantages.
</p>

<p>
One disadvantage is code repetition. For example the for → while nanopass would duplicate the entire datatype except removing the for loop.
</p>

<p>
Another disadvantage is that the pass order becomes very unflexable, the λ → class and the for → while could logically be swapped, but this would not be possible because of different datatypes
</p>
</div>
</div>
<div id="outline-container-orgb13f85a" class="outline-4">
<h4 id="orgb13f85a"><span class="section-number-4">11.2.2.</span> One AST</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
LLVM uses this option.
</p>

<p>
The major disadvantage here is no type safety.
</p>

<p>
The result of a for → while pass should never include a for loop, but this would be possible if every pass uses the same AST
</p>
</div>
</div>
<div id="outline-container-org80c5731" class="outline-4">
<h4 id="org80c5731"><span class="section-number-4">11.2.3.</span> Generics</h4>
<div class="outline-text-4" id="text-11-2-3">
<p>
Describe the change in AST that should happen after each pass.
</p>

<p>
<img src="Nanopass_Compilation/2024-01-30_17-08-05_screenshot.png" alt="2024-01-30_17-08-05_screenshot.png" />
\(\Delta_1\) could be remove for loop for example.
</p>

<p>
In the language Racket this is possible by default.
</p>

<p>
It&rsquo;s not possible in default haskell.
</p>

<p>
If done it could look something like this:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef; font-weight: bold;">{-# LANGUAGE TemplateHaskell #-}</span>

<span style="color: #51afef;">import</span> <span style="color: #ECBE7B;">Vaporware.Generics.Library</span>

<span style="color: #c678dd;">patch4</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">&#916;Data</span>
<span style="color: #c678dd;">patch4</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">\</span>exp <span style="color: #dcaeea;">-&gt;</span>
    [ <span style="color: #ECBE7B;">RemoveConstructor</span> <span style="color: #98be65;">"For"</span> [(exp,exp,exp),exp]
    , <span style="color: #ECBE7B;">AddConstructor</span> <span style="color: #98be65;">"While"</span> [exp, exp]
    ]

<span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Exp4</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">$</span>(patch_datatype <span style="color: #ECBE7B;">Exp3</span> patch4)

<span style="color: #c678dd;">for2while</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Ast3.Exp</span>
<span style="color: #c678dd;">for2while</span> (<span style="color: #ECBE7B;">For</span> (i,c,n) b) <span style="color: #dcaeea;">=</span> i <span style="color: #dcaeea;">`Seq`</span> <span style="color: #ECBE7B;">While</span> c (b <span style="color: #dcaeea;">`Seq`</span> n)
<span style="color: #c678dd;">for2while</span> <span style="color: #51afef;">_</span> <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">$</span>(generate_fold_boilerplate)
</pre>
</div>

<p>
It is generally speaking also quite complicated.
</p>

<p>
There is still a lot of research being done for this.
</p>
</div>
</div>
<div id="outline-container-org0fa1756" class="outline-4">
<h4 id="org0fa1756"><span class="section-number-4">11.2.4.</span> One AST, with refinements</h4>
<div class="outline-text-4" id="text-11-2-4">
<p>
Can be seen as a combinations of one AST and generics.
</p>

<p>
In haskell self we just use the single AST, but we add liquid haskell, a program verifier to add refinements.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef; font-weight: bold;">{-@ type Exp3 = {e :: Exp | noWhile e &amp;&amp; ...} @-}</span>
<span style="color: #51afef; font-weight: bold;">{-@ type Exp4 = {e :: Exp | noFor e &amp;&amp; ...} @-}</span>

<span style="color: #51afef; font-weight: bold;">{-@ for2while :: Exp3 -&gt; Exp4 @-}</span>
<span style="color: #c678dd;">for2while</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Exp</span>
</pre>
</div>

<p>
The disadvantage here is difficulty in setting up, and it not being default haskell
</p>
</div>
</div>
<div id="outline-container-org68f5b4d" class="outline-4">
<h4 id="org68f5b4d"><span class="section-number-4">11.2.5.</span> One AST, with parameters</h4>
<div class="outline-text-4" id="text-11-2-5">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Exp</span> a b c d e f g h <span style="color: #dcaeea;">...</span> <span style="color: #5B6268;">-- </span><span style="color: #5B6268;">One param per ctr.</span>
<span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Raw</span> a <span style="color: #ECBE7B;">String</span>
<span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">If</span> b <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
<span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Goto</span> c <span style="color: #ECBE7B;">Label</span>
<span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Instr</span> d <span style="color: #ECBE7B;">SSM.Instr</span>
<span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Typed</span> e <span style="color: #ECBE7B;">Type</span> <span style="color: #ECBE7B;">Exp</span>
<span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">For</span> f (<span style="color: #ECBE7B;">Exp</span>,<span style="color: #ECBE7B;">Exp</span>,<span style="color: #ECBE7B;">Exp</span>) <span style="color: #ECBE7B;">Exp</span>
<span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">While</span> g <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
<span style="color: #dcaeea;">|</span> <span style="color: #dcaeea;">...</span>

<span style="color: #c678dd;">for2while</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Exp</span> a b c d e for  while <span style="color: #dcaeea;">...</span>
          <span style="color: #dcaeea;">-&gt;</span> <span style="color: #ECBE7B;">Exp</span> a b c d e <span style="color: #ECBE7B;">Void</span> <span style="color: #ECBE7B;">()</span>    <span style="color: #dcaeea;">...</span>
</pre>
</div>
<p>
This is Pattern-checker friendly and make re-ordering easy.
</p>

<p>
The disadvantage is that this results in big types.
</p>
</div>
</div>
<div id="outline-container-org3033098" class="outline-4">
<h4 id="org3033098"><span class="section-number-4">11.2.6.</span> <span class="todo TODO">TODO</span> One AST, with parameter + type functions</h4>
<div class="outline-text-4" id="text-11-2-6">
<p>
Geen idee nog hoe dit werkt
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Exp</span> &#950;
    <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Raw</span> (<span style="color: #ECBE7B;">XRaw</span> &#950;) <span style="color: #ECBE7B;">String</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">If</span> (<span style="color: #ECBE7B;">XIf</span> &#950;) <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Goto</span> (<span style="color: #ECBE7B;">XGoto</span> &#950;) <span style="color: #ECBE7B;">Label</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Instr</span> (<span style="color: #ECBE7B;">XInstr</span> &#950;) <span style="color: #ECBE7B;">SSM.Instr</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Typed</span> (<span style="color: #ECBE7B;">XTyped</span> &#950;) <span style="color: #ECBE7B;">Type</span> <span style="color: #ECBE7B;">Exp</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">For</span> (<span style="color: #ECBE7B;">XFor</span> &#950;) (<span style="color: #ECBE7B;">Exp</span>,<span style="color: #ECBE7B;">Exp</span>,<span style="color: #ECBE7B;">Exp</span>) <span style="color: #ECBE7B;">Exp</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">While</span> (<span style="color: #ECBE7B;">XWhile</span> &#950;) <span style="color: #ECBE7B;">Exp</span> <span style="color: #ECBE7B;">Exp</span>
    <span style="color: #dcaeea;">|</span> <span style="color: #dcaeea;">...</span>

<span style="color: #5B6268;">-- </span><span style="color: #5B6268;">One type per ctr.</span>
<span style="color: #51afef;">type</span> <span style="color: #51afef;">family</span> <span style="color: #ECBE7B;">XRaw</span> &#950;
<span style="color: #51afef;">type</span> <span style="color: #51afef;">family</span> <span style="color: #ECBE7B;">XIf</span> &#950;
<span style="color: #51afef;">type</span> <span style="color: #51afef;">family</span> <span style="color: #ECBE7B;">XGoto</span> &#950;
<span style="color: #51afef;">type</span> <span style="color: #51afef;">family</span> <span style="color: #ECBE7B;">XInstr</span> &#950;
<span style="color: #51afef;">type</span> <span style="color: #51afef;">family</span> <span style="color: #ECBE7B;">XTyped</span> &#950;
<span style="color: #51afef;">type</span> <span style="color: #51afef;">family</span> <span style="color: #ECBE7B;">XFor</span> &#950;
<span style="color: #51afef;">type</span> <span style="color: #51afef;">family</span> <span style="color: #ECBE7B;">XWhile</span> &#950;
</pre>
</div>

<p>
<a href="https://wiki.haskell.org/GHC/Type_families">https://wiki.haskell.org/GHC/Type_families</a>
</p>

<p>
<a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow">https://gitlab.haskell.org/ghc/ghc/-/wikis/implementing-trees-that-grow</a>
</p>

<p>
<a href="https://ics.uu.nl/docs/vakken/b3tc/downloads-2018/TC-14-final.pdf">https://ics.uu.nl/docs/vakken/b3tc/downloads-2018/TC-14-final.pdf</a>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd0d4052" class="outline-2">
<h2 id="orgd0d4052"><span class="section-number-2">12.</span> Optimizations</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-orgbef7bed" class="outline-3">
<h3 id="orgbef7bed"><span class="section-number-3">12.1.</span> Optimization passes</h3>
<div class="outline-text-3" id="text-12-1">
<p>
What is a compiler optimization?
</p>
<ul class="org-ul">
<li>A bad name</li>
<li>A semantics-preverving code transformation</li>
<li>Hopefully imporving the code by some metric</li>
</ul>

<p>
Optimization passes can be visualized as so:
<img src="Optimizations/2024-01-23_09-06-30_screenshot.png" alt="2024-01-23_09-06-30_screenshot.png" />
</p>
</div>
</div>
<div id="outline-container-org99a0ef4" class="outline-3">
<h3 id="org99a0ef4"><span class="section-number-3">12.2.</span> Simple optimizations</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li>Group of simple but effective optimizations</li>
<li>Find and replace</li>
<li>Usually on low-level instructions</li>
</ul>

<p>
<i>Examples</i>:
</p>
<ul class="org-ul">
<li>\(x * 2 \Rightarrow x << 1\)</li>
<li>\(x * 0 \Rightarrow 0\)</li>
<li>\(x \leftarrow 3;x \leftarrow 4 \Rightarrow x \leftarrow 4\)</li>
</ul>
</div>
<div id="outline-container-org53423eb" class="outline-4">
<h4 id="org53423eb"><span class="section-number-4">12.2.1.</span> Unreachable/dead code elimination:</h4>
<div class="outline-text-4" id="text-12-2-1">
<ul class="org-ul">
<li>Uncalled methods/functions</li>
<li>Code after a return statement</li>
<li>Patterns that cannot be matched</li>
</ul>
</div>
</div>
<div id="outline-container-org2c99213" class="outline-4">
<h4 id="org2c99213"><span class="section-number-4">12.2.2.</span> Tail call elimination:</h4>
<div class="outline-text-4" id="text-12-2-2">
<p>
Turn a simple recursive function into a loop, removes a lot of overhead from function calls. Also prevent stack from growing.
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">add</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">if</span> <span style="color: #c678dd;">(</span>m = <span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">)</span> then
        <span style="color: #51afef;">return</span> n;
    <span style="color: #51afef;">else</span>
        <span style="color: #51afef;">return</span> add <span style="color: #c678dd;">(</span>m &#8722; <span style="color: #da8548; font-weight: bold;">1</span>, n + <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">add</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">m</span>, <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">n</span><span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">while</span> <span style="color: #c678dd;">(</span>m <span style="color: #51afef; font-weight: bold;">!</span> = <span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
        m = m &#8722; <span style="color: #da8548; font-weight: bold;">1</span>;
        n = n + <span style="color: #da8548; font-weight: bold;">1</span>;
    <span style="color: #c678dd;">}</span>
    <span style="color: #51afef;">return</span> n;
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org066b2ec" class="outline-3">
<h3 id="org066b2ec"><span class="section-number-3">12.3.</span> Loop optimization</h3>
<div class="outline-text-3" id="text-12-3">
</div>
<div id="outline-container-org57a7975" class="outline-4">
<h4 id="org57a7975"><span class="section-number-4">12.3.1.</span> Loop unrolling</h4>
<div class="outline-text-4" id="text-12-3-1">
<p>
Removes some overhead from the loop, such as jumps, checking the condition.
</p>

<ul class="org-ul">
<li>In this example, n needs to be divisible by 4.</li>
<li>Side effects should not be in condition</li>
</ul>

<p>
Possibly more cache misses.
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n &#8722; <span style="color: #da8548; font-weight: bold;">4</span>; i + = <span style="color: #da8548; font-weight: bold;">4</span><span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
    doStuff <span style="color: #c678dd;">(</span>i + <span style="color: #da8548; font-weight: bold;">1</span><span style="color: #c678dd;">)</span>;
    doStuff <span style="color: #c678dd;">(</span>i + <span style="color: #da8548; font-weight: bold;">2</span><span style="color: #c678dd;">)</span>;
    doStuff <span style="color: #c678dd;">(</span>i + <span style="color: #da8548; font-weight: bold;">3</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc7d5156" class="outline-4">
<h4 id="orgc7d5156"><span class="section-number-4">12.3.2.</span> Loop invariant code motion</h4>
<div class="outline-text-4" id="text-12-3-2">
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    x = <span style="color: #da8548; font-weight: bold;">10</span> * y + cos <span style="color: #c678dd;">(</span><span style="color: #da8548; font-weight: bold;">0.5</span><span style="color: #c678dd;">)</span>;
    doStuff <span style="color: #c678dd;">(</span>i, x<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp">x = <span style="color: #da8548; font-weight: bold;">10</span> * y + cos <span style="color: #51afef;">(</span><span style="color: #da8548; font-weight: bold;">0.5</span><span style="color: #51afef;">)</span>;
<span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff <span style="color: #c678dd;">(</span>i, x<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org0068862" class="outline-4">
<h4 id="org0068862"><span class="section-number-4">12.3.3.</span> Loop fusion</h4>
<div class="outline-text-4" id="text-12-3-3">
<p>
Less overhead from jumps and conditions.
</p>

<p>
The functions can influence each other, just make sure the order doesn&rsquo;t change.
</p>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff1 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff2 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff1 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
    doStuff2 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Vertical fusion:
</p>

<ul class="org-ul">
<li>Replacing an array with a scalar</li>
<li>Eliminating n array reads and writes</li>
</ul>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
y <span style="color: #c678dd;">[</span>i<span style="color: #c678dd;">]</span> = <span style="color: #da8548; font-weight: bold;">2</span> &#8727; x <span style="color: #c678dd;">[</span>i<span style="color: #c678dd;">]</span>;
<span style="color: #51afef;">}</span>
<span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
z <span style="color: #c678dd;">[</span>i<span style="color: #c678dd;">]</span> = <span style="color: #da8548; font-weight: bold;">4</span> + y <span style="color: #c678dd;">[</span>i<span style="color: #c678dd;">]</span>;
<span style="color: #51afef;">}</span>
<span style="color: #51afef;">return</span> z;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgff27d28" class="outline-4">
<h4 id="orgff27d28"><span class="section-number-4">12.3.4.</span> Loop fission</h4>
<div class="outline-text-4" id="text-12-3-4">
<p>
Oposite of fussion.
</p>
<ul class="org-ul">
<li>Sometimes one is better, sometimes the other.</li>
</ul>

<p>
Can be better for cache reasons.
</p>
<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff1 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
    doStuff2 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-csharp"><span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff1 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef;">for</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; n; i++<span style="color: #51afef;">)</span>
<span style="color: #51afef;">{</span>
    doStuff2 <span style="color: #c678dd;">(</span>i<span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org83586f1" class="outline-3">
<h3 id="org83586f1"><span class="section-number-3">12.4.</span> Other optimizations</h3>
<div class="outline-text-3" id="text-12-4">
</div>
<div id="outline-container-orgae731a2" class="outline-4">
<h4 id="orgae731a2"><span class="section-number-4">12.4.1.</span> Inlining</h4>
<div class="outline-text-4" id="text-12-4-1">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">let</span> x <span style="color: #dcaeea;">=</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #51afef;">in</span> x <span style="color: #dcaeea;">*</span> y <span style="color: #dcaeea;">+</span> x
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #dcaeea;">*</span> y <span style="color: #dcaeea;">+</span> <span style="color: #da8548; font-weight: bold;">5</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc038c22" class="outline-4">
<h4 id="orgc038c22"><span class="section-number-4">12.4.2.</span> Common Subexpression Elimination</h4>
<div class="outline-text-4" id="text-12-4-2">
<p>
Opposite of inlining: Tradeoff between computation and memory
</p>

<div class="org-src-container">
<pre class="src src-haskell">cos(<span style="color: #da8548; font-weight: bold;">5</span><span style="color: #dcaeea;">*</span>x)<span style="color: #dcaeea;">/</span>(<span style="color: #da8548; font-weight: bold;">1</span><span style="color: #dcaeea;">+</span>cos(<span style="color: #da8548; font-weight: bold;">5</span><span style="color: #dcaeea;">*</span>x))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">let</span> y<span style="color: #dcaeea;">=</span>cos(<span style="color: #da8548; font-weight: bold;">5</span><span style="color: #dcaeea;">*</span>x) <span style="color: #51afef;">in</span> y <span style="color: #dcaeea;">/</span> (<span style="color: #da8548; font-weight: bold;">1</span><span style="color: #dcaeea;">+</span>y)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org389e682" class="outline-3">
<h3 id="org389e682"><span class="section-number-3">12.5.</span> Compiler pipeline</h3>
<div class="outline-text-3" id="text-12-5">

<div id="org77a0cac" class="figure">
<p><img src="Optimizations/2024-01-23_10-04-39_screenshot.png" alt="2024-01-23_10-04-39_screenshot.png" />
</p>
</div>
<ul class="org-ul">
<li>Source: haskell</li>
<li>Desugared: guards, typeclass and do desugared</li>
<li>Core: more lambda dan haskell, optimizations are looped. An inline can open up another optimization for example</li>
<li>STG: intermediate, basically a primitive version of c</li>
<li>CMM: actual build target</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Martijn Voordouw</p>
<p class="date">Created: 2024-01-31 Wed 12:29</p>
</div>
</body>
</html>
